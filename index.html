<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#2c3e50">
    <meta name="msapplication-navbutton-color" content="#2c3e50">
    <meta name="apple-mobile-web-app-title" content="BELGESELSEMO PDF VIEWER">
    <title>BELGESELSEMO PDF VIEWER</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --header-bg-start: #2c3e50;
            --header-bg-end: #1a2530;
            --footer-bg-start: #1a2530;
            --footer-bg-end: #2c3e50;
            --accent-color: #3498db;
            --active-color: #f97316;
            --hover-color: rgba(255, 255, 255, 0.2);
            --drawing-toolbar-bg: rgba(52, 73, 94, 0.95);
            --toolbar-icon-size: 20px;
            --toolbar-height: 45px;
            --main-bg-start: #33799d;
            --main-bg-end: #e8ebb4;
            --selection-color: rgba(52, 152, 219, 0.3);
            --selection-border: #3498db;
            --highlight-color: rgba(255, 255, 0, 0.4);
            --popup-bg: #2a3441;
            --popup-border: #3e4a59;
            --text-primary: #ffffff;
            --text-secondary: #b8c5d1;
            --bookmarks-bg: rgba(52, 73, 94, 0.95);
            --thumbnail-bg: rgba(42, 52, 65, 0.95);
            --thumbnail-hover: rgba(52, 152, 219, 0.2);
            --note-favorite: #ffd700;
            --note-category-work: #e74c3c;
            --note-category-study: #3498db;
            --note-category-personal: #9b59b6;
        }

        /* Theme definitions */
        .theme-default {
            --header-bg-start: #2c3e50;
            --header-bg-end: #1a2530;
            --footer-bg-start: #1a2530;
            --footer-bg-end: #2c3e50;
            --main-bg-start: #33799d;
            --main-bg-end: #e8ebb4;
            --accent-color: #3498db;
        }

        .theme-forest {
            --header-bg-start: #2d5a27;
            --header-bg-end: #1a3515;
            --footer-bg-start: #1a3515;
            --footer-bg-end: #2d5a27;
            --main-bg-start: #4a7c59;
            --main-bg-end: #a7c957;
            --accent-color: #6a994e;
        }

        .theme-sunset {
            --header-bg-start: #c73e1d;
            --header-bg-end: #8b1538;
            --footer-bg-start: #8b1538;
            --footer-bg-end: #c73e1d;
            --main-bg-start: #f18701;
            --main-bg-end: #fcbf49;
            --accent-color: #ee6c4d;
        }

        .theme-ocean {
            --header-bg-start: #03045e;
            --header-bg-end: #001d3d;
            --footer-bg-start: #001d3d;
            --footer-bg-end: #03045e;
            --main-bg-start: #0077b6;
            --main-bg-end: #90e0ef;
            --accent-color: #00b4d8;
        }

        .theme-purple {
            --header-bg-start: #5a189a;
            --header-bg-end: #240046;
            --footer-bg-start: #240046;
            --footer-bg-end: #5a189a;
            --main-bg-start: #7209b7;
            --main-bg-end: #c77dff;
            --accent-color: #9d4edd;
        }

        .theme-dark {
            --header-bg-start: #1a1a1a;
            --header-bg-end: #000000;
            --footer-bg-start: #000000;
            --footer-bg-end: #1a1a1a;
            --main-bg-start: #2c2c2c;
            --main-bg-end: #1a1a1a;
            --accent-color: #4a9eff;
        }

        .theme-golden {
            --header-bg-start: #b8860b;
            --header-bg-end: #8b6914;
            --footer-bg-start: #8b6914;
            --footer-bg-end: #b8860b;
            --main-bg-start: #daa520;
            --main-bg-end: #ffd700;
            --accent-color: #ff8c00;
        }

        .theme-emerald {
            --header-bg-start: #0f5132;
            --header-bg-end: #198754;
            --footer-bg-start: #198754;
            --footer-bg-end: #0f5132;
            --main-bg-start: #20c997;
            --main-bg-end: #d1ecf1;
            --accent-color: #17a2b8;
        }

        .theme-crimson {
            --header-bg-start: #8b0000;
            --header-bg-end: #dc143c;
            --footer-bg-start: #dc143c;
            --footer-bg-end: #8b0000;
            --main-bg-start: #ff1744;
            --main-bg-end: #ffcdd2;
            --accent-color: #e91e63;
        }

        .theme-royal {
            --header-bg-start: #4b0082;
            --header-bg-end: #6a5acd;
            --footer-bg-start: #6a5acd;
            --footer-bg-end: #4b0082;
            --main-bg-start: #9370db;
            --main-bg-end: #e6e6fa;
            --accent-color: #8a2be2;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            height: 100%;
            width: 100%;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            position: relative;
            background: linear-gradient(135deg, var(--main-bg-start), var(--main-bg-end));
            transition: background 0.3s ease;
            overflow-x: hidden;
        }

        /* ENHANCED RESPONSIVE HEADER LAYOUT */
        .header {
            background: linear-gradient(to bottom, var(--header-bg-start), var(--header-bg-end));
            color: white;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: var(--toolbar-height);
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            position: relative;
            transition: all 0.3s ease;
            gap: 12px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 0 0 auto;
            min-width: 0;
        }

        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            min-width: 0;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 0 0 auto;
            justify-content: flex-end;
            min-width: 0;
        }

        .logo {
            height: 32px;
            width: 32px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: transform 0.2s ease;
            cursor: pointer;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            background-image: url('https://a.calameoassets.com/3359034/picture.jpg');
            background-size: cover;
            background-position: center;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .header-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--accent-color);
            white-space: nowrap;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .icon-group {
            display: flex;
            gap: 5px;
            align-items: center;
            flex-wrap: nowrap;
            overflow: hidden;
        }

        .icon {
            width: 22px;
            height: 22px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            border-radius: 4px;
            padding: 3px;
        }

        .icon:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.1);
            color: var(--accent-color);
        }

        .icon.active {
            color: var(--active-color);
            background: rgba(249, 115, 22, 0.2);
        }

        /* ENHANCED DRAGGABLE DRAWING TOOLBAR - MOBILE OPTIMIZED */
        .drawing-toolbar {
            position: fixed;
            top: 50px;
            left: 2%;
            width: 96%;
            background: var(--drawing-toolbar-bg);
            border-radius: 12px;
            padding: 8px 12px;
            z-index: 250;
            display: none;
            flex-wrap: wrap;
            gap: 6px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            align-items: center;
            justify-content: flex-start;
            min-height: 55px;
            max-height: 130px;
            overflow-y: auto;
            cursor: default;
            transition: all 0.3s ease;
        }

        .drawing-toolbar.show {
            display: flex;
        }

        .drawing-toolbar.dragging {
            transform: rotate(2deg);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
            z-index: 300;
        }

        .drawing-toolbar::-webkit-scrollbar {
            height: 4px;
        }

        .drawing-toolbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .drawing-toolbar::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 2px;
        }

        /* MOBILE OPTIMIZED - TOOLBAR APPEARS OVER CONTENT */
        @media (max-width: 768px) {
            .drawing-toolbar {
                top: 42px;
                left: 3px;
                width: 52px;
                height: calc(100vh - 130px);
                flex-direction: column;
                padding: 6px 3px;
                overflow-y: auto;
                overflow-x: hidden;
                border-radius: 10px;
                max-height: none;
                z-index: 260; /* Higher z-index to appear over content */
            }

            /* PDF pages should NOT be affected by toolbar in mobile */
            .main-content.drawing-active {
                padding-left: 0 !important; /* Override any left padding */
                padding-top: 0;
            }

            .pdf-page {
                width: calc(100vw - 10px) !important;
                max-width: calc(100vw - 10px) !important;
                /* Enhanced mobile scrolling optimization */
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
                contain: layout style paint;
                isolation: isolate;
            }

            /* Mobile specific optimizations for smooth scrolling */
            .main-content {
                -webkit-overflow-scrolling: touch !important;
                overscroll-behavior-y: contain;
                scroll-snap-type: y proximity;
                scroll-behavior: smooth;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
            }

            .pdf-page {
                scroll-snap-align: start;
                margin-bottom: 10px;
                /* Reduce repaints on mobile */
                will-change: transform;
                contain: layout style paint size;
            }
        }

        /* MOVE HANDLE FOR DRAGGING */
        .toolbar-move-handle {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-right: 6px;
        }

        .toolbar-move-handle:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .toolbar-move-handle:active {
            background: var(--accent-color);
            color: white;
        }

        .tool-group {
            display: flex;
            gap: 3px;
            align-items: center;
            padding: 2px 5px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-right: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-group::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;
            height: 1px;
            background: var(--accent-color);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tool-group:hover::before {
            opacity: 0.7;
        }

        .drawing-tool {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.05);
            font-size: 11px;
            position: relative;
        }

        .drawing-tool:hover {
            color: white;
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .drawing-tool.active {
            color: var(--active-color);
            border-color: var(--active-color);
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.2), rgba(249, 115, 22, 0.1));
            box-shadow: 0 0 12px rgba(249, 115, 22, 0.3);
        }

        .drawing-tool.active::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 5px;
            height: 2px;
            background: var(--active-color);
            border-radius: 1px;
        }

        .color-picker {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .color-picker:hover {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
        }

        .color-picker.active {
            border-color: var(--accent-color);
            box-shadow: 0 0 12px rgba(52, 152, 219, 0.5);
            transform: scale(1.2);
        }

        .color-picker.active::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 9px;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        /* ADVANCED CONTROLS */
        .advanced-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .brush-size-group {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 3px 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .brush-size-slider {
            width: 55px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .brush-size-slider::-webkit-slider-thumb {
            appearance: none;
            width: 11px;
            height: 11px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .brush-size-display {
            color: rgba(255, 255, 255, 0.8);
            font-size: 9px;
            min-width: 18px;
            text-align: center;
            font-weight: bold;
        }

        .opacity-slider {
            width: 45px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .opacity-slider::-webkit-slider-thumb {
            appearance: none;
            width: 11px;
            height: 11px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* SELECTION INDICATORS */
        .selection-count {
            color: rgba(255, 255, 255, 0.8);
            font-size: 9px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 10px;
            position: absolute;
            top: -7px;
            right: -7px;
            min-width: 14px;
            text-align: center;
        }

        /* CUSTOM CURSORS FOR DRAWING TOOLS */
        .cursor-pen { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>') 12 12, crosshair !important; }

        .cursor-eraser { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.5l9.6-9.6c1-1 2.5-1 3.5 0l5.2 5.2c1 1 1 2.5 0 3.5L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>') 12 12, crosshair !important; }

        .cursor-hand { cursor: grab !important; }
        .cursor-hand:active { cursor: grabbing !important; }

        .cursor-rectSelect { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M9 9h6v6H9V9z"/></svg>') 12 12, crosshair !important; }

        .cursor-lasso { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="m3 3 2.01 2.01"/><path d="m7 7 2.01 2.01"/></svg>') 12 12, crosshair !important; }

        .cursor-screenshot { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>') 12 12, crosshair !important; }

        .cursor-text { cursor: text !important; }

        .cursor-measure { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="7.5 4.21 12 6.81 16.5 4.21"/><polyline points="7.5 19.79 7.5 14.6 3 12"/><polyline points="21 12 16.5 14.6 16.5 19.79"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>') 12 12, crosshair !important; }

        .cursor-numberline { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="8" x2="3" y2="16"/><line x1="9" y1="10" x2="9" y2="14"/><line x1="15" y1="10" x2="15" y2="14"/><line x1="21" y1="8" x2="21" y2="16"/></svg>') 12 12, crosshair !important; }

        /* POPUP OVERLAY AND CONTENT */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .popup-overlay.hidden {
            display: none;
        }

        .popup-content {
            background: linear-gradient(135deg, var(--popup-bg), #1e2832);
            border-radius: 12px;
            padding: 24px;
            border: 1px solid var(--popup-border);
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            color: var(--text-primary);
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--popup-border);
        }

        .popup-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-color);
        }

        .popup-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .popup-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        /* URL INPUT POPUP */
        .url-input-popup {
            width: 400px;
            max-width: 90vw;
        }

        .url-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--popup-border);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 16px;
            resize: none;
            font-family: inherit;
            line-height: 1.4;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }

        .url-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
        }

        .url-input::placeholder {
            color: var(--text-secondary);
        }

        /* Enhanced paste support */
        .url-input::-webkit-input-placeholder {
            color: var(--text-secondary);
        }

        .url-input::-moz-placeholder {
            color: var(--text-secondary);
            opacity: 1;
        }

        .url-input:-ms-input-placeholder {
            color: var(--text-secondary);
        }

        .popup-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .popup-button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .popup-button.primary {
            background: var(--accent-color);
            color: white;
        }

        .popup-button.primary:hover {
            background: #2980b9;
        }

        .popup-button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--popup-border);
        }

        .popup-button.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* URL LOADING AND STATUS */
        .url-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .url-loading.hidden {
            display: none;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .url-loading-text {
            color: var(--text-primary);
            font-size: 14px;
        }

        .url-progress {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .url-progress-bar {
            height: 100%;
            background: var(--accent-color);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .url-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 12px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
        }

        .url-status.hidden {
            display: none;
        }

        .url-status.success {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid rgba(39, 174, 96, 0.3);
            color: #2ecc71;
        }

        .url-status.warning {
            background: rgba(241, 196, 15, 0.2);
            border: 1px solid rgba(241, 196, 15, 0.3);
            color: #f1c40f;
        }

        .url-status.error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .url-status-icon {
            font-size: 14px;
        }

        .url-status-text {
            flex: 1;
        }

        /* RESPONSIVE WELCOME SCREEN */
        .welcome-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 15px;
            background: transparent;
            overflow: hidden;
            width: 100%;
            height: calc(100vh - var(--toolbar-height) * 2);
            min-height: calc(100vh - var(--toolbar-height) * 2);
            max-height: calc(100vh - var(--toolbar-height) * 2);
        }

        .welcome-content {
            background: rgba(0, 0, 0, 0.7);
            padding: 25px;
            border-radius: 16px;
            max-width: 1200px;
            width: 100%;
            height: 100%;
            margin: 0 auto;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            max-height: 100%;
        }

        .welcome-title {
            font-size: 2.2rem;
            margin-bottom: 12px;
            background: linear-gradient(45deg, #fff, var(--accent-color), #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .welcome-subtitle {
            font-size: 1rem;
            margin-bottom: 20px;
            opacity: 0.9;
            line-height: 1.5;
            flex-shrink: 0;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
        }

        .feature-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .feature-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            transition: left 0.5s ease;
        }

        .feature-item:hover {
            transform: translateY(-3px);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .feature-item:hover::before {
            left: 100%;
        }

        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--accent-color);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feature-title {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 6px;
            color: white;
        }

        .feature-desc {
            font-size: 0.85rem;
            opacity: 0.85;
            line-height: 1.4;
        }

        .start-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
            margin-top: auto;
            padding-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            min-width: 120px;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: var(--accent-color);
            color: white;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn-outline {
            background: transparent;
            color: white;
            border: 2px solid var(--accent-color);
        }

        .btn-outline:hover {
            background: var(--accent-color);
            color: white;
            transform: translateY(-2px);
        }

        /* ULTRA HIGH QUALITY PDF Container */
        .main-content {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, var(--main-bg-start), var(--main-bg-end));
            scroll-behavior: smooth;
            position: relative;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x pan-y pinch-zoom;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 0;
            transition: background 0.3s ease;
            transform: translateZ(0);
            contain: layout style;
            padding-top: 0;
            /* Enhanced mobile scrolling */
            overscroll-behavior: contain;
            -webkit-transform: translate3d(0,0,0);
            -moz-transform: translate3d(0,0,0);
            -ms-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
            will-change: transform;
       scroll-behavior: auto; /* smooth yerine auto */
       transform: translate3d(0,0,0);
       will-change: scroll-position;
        }

        /* REMOVED THE DRAWING-ACTIVE PADDING FOR MOBILE */
        .main-content.drawing-active {
            padding-top: 60px;
        }

        @media (max-width: 768px) {
            .main-content.drawing-active {
                padding-top: 0 !important;
                padding-left: 0 !important;
            }
        }

        .main-content::-webkit-scrollbar {
            display: none;
        }

        /* Drop Zone for Drag & Drop */
        .drop-zone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(52, 152, 219, 0.9);
            backdrop-filter: blur(10px);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            border: 4px dashed rgba(255, 255, 255, 0.8);
            margin: 20px;
            border-radius: 20px;
        }

        .drop-zone.active {
            display: flex;
        }

        .drop-zone-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .drop-zone-icon {
            font-size: 4rem;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .pdf-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 8px 0;
            gap: 5px;
            will-change: transform;
            contain: layout style paint;
        }

        .pdf-container.show {
            display: flex;
        }

        .pdf-page {
            background-color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            position: relative;
            overflow: visible;
            transform-origin: center;
            width: 100%;
            max-width: calc(100vw - 16px);
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            will-change: transform;
            contain: layout style paint;
            transition: box-shadow 0.3s ease;

            /* Mobile optimization for full width display */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .pdf-page:hover {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .pdf-page canvas {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            image-rendering: optimizeQuality;
            image-rendering: -webkit-optimize-contrast;

            /* Enhanced mobile optimization for smooth scrolling */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: transform;
            contain: layout style paint;
            -webkit-perspective: 1000px;
            perspective: 1000px;
            /* Optimize for mobile touch scrolling */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .pdf-page .loading-placeholder {
            color: #666;
            font-size: 15px;
            text-align: center;
            padding: 30px;
            cursor: pointer;
            border: 2px dashed #ddd;
            border-radius: 10px;
            background: #f9f9f9;
            transition: all 0.3s ease;
            width: 300px;
        }

        .pdf-page .loading-placeholder:hover {
            background: #f0f0f0;
            border-color: var(--accent-color);
            transform: scale(1.02);
        }

        .pdf-page .retry-btn {
            margin-top: 12px;
            padding: 10px 20px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .pdf-page .retry-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        /* ENHANCED Drawing Canvas Overlay */
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.2s ease;
        }

        .drawing-canvas.active {
            pointer-events: auto;
        }

        .drawing-canvas.drawing-mode {
            cursor: crosshair;
        }

        /* ULTRA ENHANCED SELECTION OVERLAY WITH MANIPULATION HANDLES */
        .selection-overlay {
            position: absolute;
            border: 2px dashed var(--selection-border);
            background: var(--selection-color);
            pointer-events: none;
            z-index: 15;
            display: none;
            border-radius: 4px;
            backdrop-filter: blur(2px);
            transition: all 0.3s ease;
        }

        .selection-overlay.show {
            display: block;
        }

        .selection-overlay.active {
            pointer-events: auto;
            cursor: move;
        }

        .selection-overlay.multi-selected {
            border-color: var(--active-color);
            background: rgba(249, 115, 22, 0.2);
        }

        .selection-overlay.manipulating {
            border-color: var(--active-color);
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.5);
            background: rgba(249, 115, 22, 0.1);
        }

        /* ULTRA ENHANCED MANIPULATION HANDLES */
        .manipulation-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            border: 2px solid white;
            cursor: pointer;
            z-index: 16;
            border-radius: 3px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .manipulation-handle:hover {
            background: var(--active-color);
            transform: scale(1.3);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.5);
        }

        /* ULTRA ENHANCED MANIPULATION TOOLBAR */
        .manipulation-toolbar {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 5px;
            padding: 5px;
            z-index: 17;
        }

        .manipulation-tool-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .manipulation-tool-btn:hover {
            background: var(--accent-color);
            transform: scale(1.1);
        }

        .manipulation-tool-btn.confirm:hover {
            background: #27ae60;
        }

        .manipulation-tool-btn.cancel:hover {
            background: #c0392b;
        }

        /* ULTRA ENHANCED RESIZE HANDLES */
        .handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
        .handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
        .handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
        .handle-n { top: -6px; left: calc(50% - 6px); cursor: n-resize; }
        .handle-s { bottom: -6px; left: calc(50% - 6px); cursor: s-resize; }
        .handle-w { top: calc(50% - 6px); left: -6px; cursor: w-resize; }
        .handle-e { top: calc(50% - 6px); right: -6px; cursor: e-resize; }

        /* ULTRA ENHANCED ROTATION HANDLE */
        .handle-rotate {
            top: -25px;
            left: calc(50% - 8px);
            width: 16px;
            height: 16px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M21 21v-5h-5"/></svg>') 12 12, pointer;
            background: var(--active-color);
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .handle-rotate::before {
            content: '↻';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        .handle-rotate::after {
            content: '';
            position: absolute;
            top: 16px;
            left: 6px;
            width: 2px;
            height: 15px;
            background: var(--accent-color);
            border-radius: 1px;
        }

        /* ULTRA ENHANCED MOVE HANDLE */
        .handle-move {
            top: calc(50% - 10px);
            left: calc(50% - 10px);
            width: 20px;
            height: 20px;
            cursor: move;
            background: rgba(52, 152, 219, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            border: 2px solid white;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .handle-move::before {
            content: '✚';
            font-weight: bold;
            color: white;
        }

        /* Text editing overlay */
        .text-editor {
            position: absolute;
            z-index: 20;
            background: white;
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            padding: 8px;
            min-width: 100px;
            min-height: 30px;
            resize: both;
            overflow: hidden;
        }

        .text-editor textarea {
            border: none;
            outline: none;
            resize: none;
            width: 100%;
            height: 100%;
            font-family: inherit;
            font-size: 14px;
            background: transparent;
        }

   .measurement-point {
       position: absolute;
       background: var(--accent-color);
       border: 2px solid white;
       border-radius: 50%;
       box-shadow: 0 2px 4px rgba(0,0,0,0.3);
       z-index: 20;
   }

        /* Measurement overlay */
        .measurement-line {
            position: absolute;
            background: var(--accent-color);
            height: 2px;
            z-index: 12;
            transform-origin: left center;
        }

        .measurement-label {
            position: absolute;
            background: var(--accent-color);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 13;
            white-space: nowrap;
        }

        /* Number line overlay */
        .numberline-overlay {
            position: absolute;
            z-index: 12;
            pointer-events: none;
        }

        .numberline-ruler {
            background: var(--accent-color);
            height: 2px;
            position: relative;
        }

        .numberline-tick {
            position: absolute;
            background: var(--accent-color);
            width: 1px;
        }

        .numberline-tick.major {
            height: 20px;
            top: -9px;
        }

        .numberline-tick.minor {
            height: 10px;
            top: -4px;
        }

        .numberline-label {
            position: absolute;
            font-size: 10px;
            color: var(--accent-color);
            top: -25px;
            transform: translateX(-50%);
            font-weight: bold;
        }

        /* Grid overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
            background-image:
                linear-gradient(to right, rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            display: none;
        }

        .grid-overlay.show {
            display: block;
        }

        /* Highlight overlay */
        .highlight-overlay {
            position: absolute;
            background: var(--highlight-color);
            border: 1px solid rgba(255, 255, 0, 0.6);
            border-radius: 2px;
            pointer-events: none;
            z-index: 8;
            opacity: 0.7;
        }

        /* RIGHT CLICK CONTEXT MENU */
        .context-menu {
            position: fixed;
            z-index: 1000;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 6px 0;
            min-width: 200px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            display: none;
            backdrop-filter: blur(15px);
        }

        .context-menu-item {
            padding: 12px 20px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 14px;
            transition: all 0.2s ease;
            position: relative;
        }

        .context-menu-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-color);
            transform: scaleY(0);
            transition: transform 0.2s ease;
        }

        .context-menu-item:hover {
            background: var(--accent-color);
            padding-left: 25px;
        }

        .context-menu-item:hover::before {
            transform: scaleY(1);
        }

        .context-menu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .context-menu-separator {
            height: 1px;
            background: #404040;
            margin: 6px 0;
        }

        .context-menu-item i {
            width: 18px;
            text-align: center;
            font-size: 14px;
        }

        /* Enhanced Footer */
        .footer {
            background: linear-gradient(to bottom, var(--footer-bg-start), var(--footer-bg-end));
            color: white;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: var(--toolbar-height);
            flex-shrink: 0;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            position: relative;
            transition: background 0.3s ease;
        }

        .footer-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .footer-center {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .footer-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .footer-icon {
            width: 26px;
            height: 26px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            border-radius: 6px;
            padding: 5px;
            position: relative;
        }

        .footer-icon:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.1);
        }

        .footer-icon.active {
            background: var(--active-color);
            color: white;
            box-shadow: 0 0 12px rgba(249, 115, 22, 0.4);
        }

        .page-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .page-icon {
            width: 26px;
            height: 26px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            border-radius: 6px;
            padding: 5px;
        }

        .page-icon:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.1);
        }

        .page-icon:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .page-input {
            width: 45px;
            padding: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 6px;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
        }

        .page-info {
            color: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            white-space: nowrap;
            font-weight: bold;
        }

        /* Auto Scroll Controls */
        .auto-scroll-container {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border-radius: 30px;
            padding: 12px 25px;
            display: none;
            align-items: center;
            gap: 18px;
            z-index: 200;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            min-width: 320px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        .auto-scroll-container.show {
            display: flex;
        }

        .scroll-speed-btn {
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .scroll-speed-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .scroll-speed-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .scroll-speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--active-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .scroll-speed-value {
            color: white;
            font-size: 14px;
            font-weight: bold;
            min-width: 45px;
            text-align: center;
        }

        /* Zoom Controls */
        .zoom-container {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border-radius: 30px;
            padding: 12px 25px;
            display: none;
            align-items: center;
            gap: 18px;
            z-index: 200;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            min-width: 320px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        .zoom-container.show {
            display: flex;
        }

        .zoom-btn {
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .zoom-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .zoom-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .zoom-value {
            color: white;
            font-size: 14px;
            font-weight: bold;
            min-width: 55px;
            text-align: center;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            backdrop-filter: blur(8px);
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: var(--popup-bg);
            border: 1px solid var(--popup-border);
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 550px;
            max-height: 75vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            position: relative;
        }

        /* Recent Files Modal - GELİŞTİRİLDİ */
        .recent-files-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            backdrop-filter: blur(8px);
        }

        /* Notes Modal */
        .notes-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notes-modal.show {
            display: flex;
            opacity: 1;
        }

        .notes-container {
            background: linear-gradient(135deg, var(--popup-bg), #1e2832);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--popup-border);
            position: relative;
        }

        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .notes-title {
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notes-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .notes-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: scale(1.1);
        }

        .add-note-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .add-note-input {
            width: 100%;
            min-height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 14px;
            resize: vertical;
            font-family: inherit;
            outline: none;
            transition: all 0.2s ease;
        }

        .add-note-input:focus {
            border-color: var(--accent-color);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .add-note-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .add-note-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .add-note-btn:hover {
            background: var(--active-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .notes-list {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }

        .notes-list::-webkit-scrollbar {
            width: 8px;
        }

        .notes-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .notes-list::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }

        .note-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent-color);
            transition: all 0.2s ease;
            position: relative;
        }

        .note-favorite-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--note-favorite);
            color: black;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .note-category {
            font-weight: bold;
            text-transform: uppercase;
        }

        .note-priority {
            color: var(--note-favorite);
            font-weight: bold;
        }

        .note-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
        }

        .note-content {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 12px;
            word-wrap: break-word;
        }

        .note-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .note-info {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .note-pdf, .note-page, .note-date {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .note-delete {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .note-delete:hover {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            transform: scale(1.1);
        }

        .no-notes {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            padding: 40px;
            font-size: 16px;
        }

        .no-notes i {
            font-size: 64px;
            margin-bottom: 20px;
            display: block;
            opacity: 0.3;
        }

        .recent-files-modal.show {
            display: flex;
        }

        .recent-files-content {
            background: var(--popup-bg);
            border: 1px solid var(--popup-border);
            border-radius: 20px;
            width: 90%;
            max-width: 550px;
            max-height: 75vh;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
        }

        .recent-files-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 30px 20px 30px;
            border-bottom: 2px solid var(--accent-color);
            flex-shrink: 0;
        }

        .recent-files-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .recent-files-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 25px 30px;
            overflow-y: auto;
            flex: 1;
        }

        /* GELİŞTİRİLMİŞ - RECENT FILE ITEM YÜKSEKLİĞİ */
        .recent-file-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            position: relative;
            overflow: visible; /* Hidden yerine visible yapıldı */
            min-height: 120px; /* Minimum yükseklik eklendi */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* İçeriği düzgün dağıt */
        }

        .recent-file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .recent-file-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-left-color: var(--accent-color);
            transform: translateX(8px);
        }

        .recent-file-item:hover::before {
            left: 100%;
        }

        .recent-file-name {
            color: white;
            font-weight: bold;
            margin-bottom: 12px; /* Margin artırıldı */
            font-size: 15px;
            word-break: break-word;
            line-height: 1.3; /* Line height eklendi */
        }

        .recent-file-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            margin-bottom: 10px; /* Margin artırıldı */
            flex-wrap: wrap; /* Wrap eklendi küçük ekranlar için */
            gap: 8px; /* Gap eklendi */
        }

        .recent-file-pages {
            color: var(--accent-color);
            font-weight: 600;
        }

        .recent-file-date {
            color: rgba(255, 255, 255, 0.7);
        }

        .recent-file-lastpage {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-style: italic;
            margin-top: auto; /* Bu satırı alta iter */
        }

        .clear-recent-btn {
            background: rgba(231, 76, 60, 0.8);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.3s ease;
            margin: 0 30px 30px 30px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .clear-recent-btn:hover {
            background: rgba(231, 76, 60, 1);
            transform: translateY(-2px);
        }

        /* Theme Selection Popup */
        .theme-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(12px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .theme-popup.show {
            display: flex;
        }

        .theme-popup-content {
            background: var(--popup-bg);
            border: 1px solid var(--popup-border);
            border-radius: 20px;
            padding: 30px;
            max-width: 650px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.6);
        }

        .theme-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--popup-border);
        }

        .theme-popup-title {
            color: var(--accent-color);
            font-size: 22px;
            font-weight: bold;
        }

        .theme-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s ease;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 18px;
            margin-bottom: 30px;
        }

        .theme-option {
            aspect-ratio: 2/1;
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            overflow: hidden;
        }

        .theme-option:hover {
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        .theme-option.active {
            border-color: #ffffff;
            box-shadow: 0 0 0 3px var(--accent-color);
            transform: scale(1.05);
        }

        .theme-option.active::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 12px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Theme option gradients */
        .theme-option[data-theme="default"] {
            background: linear-gradient(135deg, #2c3e50, #3498db, #e8ebb4);
        }

        .theme-option[data-theme="forest"] {
            background: linear-gradient(135deg, #2d5a27, #4a7c59, #a7c957);
        }

        .theme-option[data-theme="sunset"] {
            background: linear-gradient(135deg, #c73e1d, #f18701, #fcbf49);
        }

        .theme-option[data-theme="ocean"] {
            background: linear-gradient(135deg, #03045e, #0077b6, #90e0ef);
        }

        .theme-option[data-theme="purple"] {
            background: linear-gradient(135deg, #5a189a, #7209b7, #c77dff);
        }

        .theme-option[data-theme="dark"] {
            background: linear-gradient(135deg, #1a1a1a, #2c2c2c, #4a9eff);
        }

        .theme-option[data-theme="golden"] {
            background: linear-gradient(135deg, #b8860b, #daa520, #ffd700);
        }

        .theme-option[data-theme="emerald"] {
            background: linear-gradient(135deg, #0f5132, #20c997, #d1ecf1);
        }

        .theme-option[data-theme="crimson"] {
            background: linear-gradient(135deg, #8b0000, #ff1744, #ffcdd2);
        }

        .theme-option[data-theme="royal"] {
            background: linear-gradient(135deg, #4b0082, #9370db, #e6e6fa);
        }

        .custom-theme-section {
            padding-top: 25px;
            border-top: 2px solid var(--popup-border);
        }

        .custom-theme-title {
            color: var(--accent-color);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .custom-theme-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-input-label {
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
        }

        .color-input {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: none;
            transition: transform 0.2s ease;
        }

        .color-input:hover {
            transform: scale(1.1);
        }

        .apply-custom-theme {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .apply-custom-theme:hover {
            opacity: 0.8;
            transform: translateY(-2px);
        }

        /* Info and Hotkey Popups */
        .info-popup, .hotkey-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            backdrop-filter: blur(8px);
        }

        .info-popup.show, .hotkey-popup.show {
            display: flex;
        }

        .info-content, .hotkey-content {
            background: var(--popup-bg);
            border: 1px solid var(--popup-border);
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 30px 20px 30px;
            border-bottom: 2px solid var(--accent-color);
            flex-shrink: 0;
        }

        .popup-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .popup-content-scrollable {
            padding: 25px 30px;
            overflow-y: auto;
            flex: 1;
        }

        .popup-text {
            color: var(--text-primary);
            line-height: 1.6;
            text-align: justify;
            margin-bottom: 20px;
        }

        .hotkey-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .hotkey-table th,
        .hotkey-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--popup-border);
            color: var(--text-primary);
        }

        .hotkey-table th {
            background: rgba(255, 255, 255, 0.1);
            font-weight: bold;
            color: var(--accent-color);
        }

        .hotkey-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .hotkey-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            font-size: 12px;
        }

        .popup-footer {
            text-align: center;
            padding: 20px 30px 30px 30px;
            border-top: 1px solid var(--popup-border);
            color: var(--accent-color);
            font-weight: bold;
            flex-shrink: 0;
        }

        /* Toast Messages */
        .toast {
            position: fixed;
            top: -100px;
            right: 25px;
            background: #333;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 3000;
            transform: translateX(100%);
            transition: all 0.4s ease;
            max-width: 350px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            opacity: 0;
            visibility: hidden;
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(0);
            top: 60px;
            opacity: 1;
            visibility: visible;
        }

        .toast.success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .toast.error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .toast.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .toast.info {
            background: linear-gradient(135deg, var(--accent-color), #2980b9);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(8px);
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ENHANCED RESPONSIVE ANIMATIONS */
        @keyframes flash {
            0% { background-color: rgba(46, 204, 113, 0.3); }
            50% { background-color: rgba(46, 204, 113, 0.7); }
            100% { background-color: rgba(46, 204, 113, 0.3); }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes slideInFromRight {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideInFromLeft {
            0% { transform: translateX(-100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes rotateIn {
            0% { transform: rotate(-180deg) scale(0.5); opacity: 0; }
            100% { transform: rotate(0deg) scale(1); opacity: 1; }
        }

        /* ENHANCED SELECTION OVERLAY STYLES */
        .new-selection-overlay {
            border-radius: 3px;
            box-shadow: 0 0 0 2000px rgba(0, 0, 0, 0.1);
            animation: pulse 1s infinite;
        }

        .lasso-selection-overlay {
            border-radius: 3px;
            box-shadow: 0 2px 10px rgba(231, 76, 60, 0.3);
        }

        .lasso-selection-svg {
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        .loading-content h3 {
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .progress-bar {
            width: 250px;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 15px auto;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), #2980b9);
            transition: width 0.3s ease;
            width: 0%;
        }

        /* ENHANCED BOOKMARKS PANEL WITH AUTO-CLOSE */
        .bookmarks-panel {
            position: fixed;
            left: -350px;
            top: 45px;
            width: 320px;
            height: calc(100vh - 90px);
            background: var(--bookmarks-bg);
            backdrop-filter: blur(15px);
            border-right: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 200;
            transition: left 0.4s ease;
            overflow-y: auto;
            border-radius: 0 12px 12px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
        }

        .bookmarks-panel.show {
            left: 0;
        }

        .bookmarks-header {
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .bookmarks-list {
            padding: 15px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }

        .bookmarks-list::-webkit-scrollbar {
            width: 8px;
        }

        .bookmarks-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .bookmarks-list::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
            opacity: 0.7;
        }

        .bookmarks-list::-webkit-scrollbar-thumb:hover {
            background: var(--active-color);
            opacity: 1;
        }

        .bookmark-item {
            color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            cursor: pointer;
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }

        .bookmark-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-left-color: var(--accent-color);
            transform: translateX(8px);
        }

        /* ENHANCED MOBILE RESPONSIVE DESIGN */
        @media (max-width: 1200px) {
            .features-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .feature-item {
                padding: 18px 12px;
                min-height: 110px;
            }
        }

        /* MOBILE PORTRAIT MODE - ENHANCED */
        @media (max-width: 768px) {
            .welcome-screen {
                height: calc(100vh - 90px);
                min-height: calc(100vh - 90px);
                max-height: calc(100vh - 90px);
            }

            .welcome-content {
                height: 100%;
                padding: 15px;
                margin: 5px;
            }

            .header {
                flex-direction: row;
                height: auto;
                min-height: 40px;
                padding: 4px 8px;
                gap: 6px;
                flex-wrap: nowrap;
            }

            .header-left {
                flex: 0 0 auto;
                order: 1;
                gap: 8px;
            }

            .header-center {
                flex: 1;
                order: 2;
                min-width: 0;
            }

            .header-right {
                flex: 0 0 auto;
                order: 3;
                gap: 3px;
            }

            .header-title {
                font-size: 12px;
                font-weight: bold;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .icon-group {
                gap: 3px;
                flex-wrap: nowrap;
                overflow-x: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }

            .icon-group::-webkit-scrollbar {
                display: none;
            }

            .icon {
                width: 18px;
                height: 18px;
                font-size: 10px;
                flex-shrink: 0;
                padding: 2px;
            }

            .logo {
                height: 26px;
                width: 26px;
                flex-shrink: 0;
                font-size: 12px;
            }

            /* ENHANCED 2-COLUMN LAYOUT FOR MOBILE TOOLS */
            .tool-group {
                flex-direction: row;
                flex-wrap: wrap;
                width: 100%;
                padding: 3px 2px;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.15);
                margin-bottom: 3px;
                justify-content: space-between;
                gap: 2px;
            }

            .tool-group:last-child {
                border-bottom: none;
            }

            .drawing-tool {
                width: 22px;
                height: 22px;
                font-size: 10px;
                margin-bottom: 1px;
                flex: 0 0 calc(50% - 1px);
            }

            .color-picker {
                width: 18px;
                height: 18px;
                margin-bottom: 1px;
                flex: 0 0 calc(50% - 1px);
            }

            .brush-size-group, .advanced-controls {
                flex-direction: column;
                padding: 4px 2px;
                width: 100%;
            }

            .brush-size-slider, .opacity-slider {
                width: 25px;
                height: 40px;
                writing-mode: bt-lr;
                -webkit-appearance: slider-vertical;
                appearance: slider-vertical;
            }

            /* ENHANCED BOOKMARKS PANEL FOR MOBILE */
            .bookmarks-panel {
                width: 300px;
                left: calc(-100vw + 8px);
                height: calc(100vh - 90px);
                top: 42px;
            }

            .bookmarks-panel.show {
                left: 8px;
            }

            .welcome-title {
                font-size: 1.6rem;
                margin-bottom: 10px;
            }

            .welcome-subtitle {
                font-size: 0.9rem;
                margin-bottom: 15px;
            }

            .features-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-bottom: 20px;
            }

            .feature-item {
                padding: 15px 10px;
                min-height: 100px;
            }

            .feature-icon {
                font-size: 1.6rem;
                margin-bottom: 8px;
            }

            .feature-title {
                font-size: 0.9rem;
                margin-bottom: 4px;
            }

            .feature-desc {
                font-size: 0.75rem;
                line-height: 1.3;
            }

            .start-buttons {
                gap: 8px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 12px;
                min-width: 100px;
            }

            .theme-popup-content {
                width: 95%;
                padding: 20px;
            }

            .theme-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }

            .pdf-page {
                width: calc(100vw - 10px) !important;
                max-width: calc(100vw - 10px) !important;
            }

            .auto-scroll-container, .zoom-container {
                min-width: 260px;
                padding: 8px 15px;
            }

            .footer {
                padding: 3px 6px;
                height: 40px;
            }

            .footer-icon, .page-icon {
                width: 20px;
                height: 20px;
                font-size: 11px;
                padding: 3px;
            }

            .page-input {
                width: 32px;
                font-size: 9px;
                padding: 3px;
            }

            .page-info {
                font-size: 9px;
            }

            .toolbar-move-handle {
                width: 32px;
                height: 32px;
                margin-bottom: 4px;
                margin-right: 0;
                font-size: 10px;
            }

            /* MOBİL İÇİN GELİŞTİRİLMİŞ RECENT FILES */
            .recent-file-item {
                min-height: 140px; /* Mobilde daha yüksek */
                padding: 18px;
            }

            .recent-file-name {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .recent-file-details {
                font-size: 12px;
                margin-bottom: 8px;
            }

            .recent-file-lastpage {
                font-size: 11px;
            }
        }

        /* VERY SMALL SCREENS */
        @media (max-width: 480px) {
            .header-title {
                font-size: 10px;
            }

            .custom-theme-controls {
                flex-direction: column;
                align-items: flex-start;
            }

            .welcome-content {
                padding: 10px;
                margin: 2px;
            }

            .welcome-title {
                font-size: 1.4rem;
            }

            .btn {
                padding: 8px 12px;
                font-size: 11px;
                min-width: 90px;
            }

            .auto-scroll-container, .zoom-container {
                min-width: 220px;
                padding: 6px 12px;
            }

            .footer {
                gap: 3px;
                padding: 2px 4px;
            }

            .footer-left,
            .footer-right {
                gap: 3px;
            }

            .drawing-toolbar {
                width: 48px;
                left: 2px;
            }

            .drawing-tool {
                width: 20px;
                height: 20px;
                font-size: 9px;
            }

            .color-picker {
                width: 16px;
                height: 16px;
            }

            .theme-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .bookmarks-panel {
                width: 280px;
                left: calc(-100vw + 5px);
            }

            .bookmarks-panel.show {
                left: 5px;
            }

            /* ÇOK KÜÇÜK EKRANLAR İÇİN RECENT FILES */
            .recent-file-item {
                min-height: 150px; /* En küçük ekranlarda daha da yüksek */
                padding: 16px;
            }
        }

        /* Animation keyframes */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); }
            to { transform: translateX(0); }
        }

        /* Performance optimizations */
        .pdf-page, .drawing-canvas {
            transform: translateZ(0);
            will-change: transform;
        }

        /* Smooth scrolling improvements */
        .main-content {
            scroll-behavior: smooth;
        }

        /* High DPI optimizations */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .drawing-tool, .color-picker {
                image-rendering: -webkit-optimize-contrast;
            }
        }

        /* CLIPBOARD PASTE SUPPORT */
        .clipboard-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2500;
            display: none;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .clipboard-overlay.show {
            display: block;
        }

        /* THUMBNAIL PANEL STYLES */
        .thumbnail-panel {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            bottom: 45px;
            background: var(--thumbnail-bg);
            backdrop-filter: blur(15px);
            z-index: 200;
            display: none;
            flex-direction: column;
            padding: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .thumbnail-panel.show {
            display: flex;
        }

        .thumbnail-header {
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .thumbnail-close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .thumbnail-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .thumbnail-grid {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            padding: 10px;
            align-content: start;
        }

        .thumbnail-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            border: 2px solid transparent;
            opacity: 0;
            transform: translateY(20px);
            animation: thumbnailFadeIn 0.3s ease forwards;
        }

        @keyframes thumbnailFadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .thumbnail-item.loading {
            opacity: 0.5;
        }

        .thumbnail-item.loading .thumbnail-canvas {
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }

        .thumbnail-item:hover {
            background: var(--thumbnail-hover);
            border-color: var(--accent-color);
            transform: scale(1.02);
        }

        .thumbnail-item.current {
            border-color: var(--active-color);
            background: rgba(249, 115, 22, 0.2);
        }

        .thumbnail-canvas {
            width: 100%;
            max-width: 130px;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .thumbnail-label {
            color: white;
            font-size: 12px;
            margin-top: 8px;
            font-weight: 500;
        }

        .thumbnail-footer {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 768px) {
            .thumbnail-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 10px;
                padding: 5px;
            }

            .thumbnail-item {
                padding: 8px;
            }

            .thumbnail-canvas {
                max-width: 100px;
            }

            .thumbnail-label {
                font-size: 11px;
            }
        }
    </style>
</head>
<body class="theme-default">
<!-- ENHANCED RESPONSIVE HEADER -->
<header class="header">
    <div class="header-left">
        <div class="logo" onclick="toggleInfo()" title="BELGESELSEMO - Logo"></div>
    </div>

    <div class="header-center">
        <span class="header-title">BELGESELSEMO PDF VIEWER</span>
    </div>

    <div class="header-right">
        <div class="icon-group">
            <i class="fas fa-folder-open icon" onclick="openFilePicker()" title="PDF Dosyası Aç"></i>
            <i class="fas fa-link icon" onclick="showUrlPopup(event)" title="URL'den PDF Aç"></i>
            <i class="fas fa-search icon" onclick="openSearchModal(event)" title="PDF'de Ara"></i>
            <i class="fas fa-bookmark icon" onclick="toggleBookmarks(event)" title="Yer İmleri"></i>
            <i class="fas fa-undo icon" onclick="rotatePDF(-90)" title="Sola Döndür"></i>
            <i class="fas fa-redo icon" onclick="rotatePDF(90)" title="Sağa Döndür"></i>
            <i class="fas fa-palette icon" onclick="showThemePopup(event)" title="Tema Değiştir"></i>
            <i class="fas fa-info-circle icon" onclick="showInfoPopup(event)" title="Bilgi"></i>
            <i class="fas fa-keyboard icon" onclick="showHotkeyPopup(event)" title="Kısayollar"></i>
            <i class="fas fa-expand icon" onclick="toggleFullscreen()" title="Tam Ekran"></i>
        </div>
    </div>
</header>

<!-- Drop Zone for Drag & Drop -->
<div class="drop-zone" id="dropZone">
    <div class="drop-zone-content">
        <div class="drop-zone-icon">
            <i class="fas fa-file-pdf"></i>
        </div>
        <div>PDF dosyasını buraya sürükleyip bırakın</div>
        <div style="font-size: 1.2rem; margin-top: 10px; opacity: 0.8;">
            Desteklenen format: .pdf
        </div>
    </div>
</div>

<!-- ULTRA ENHANCED DRAGGABLE DRAWING TOOLBAR WITH ALL SHAPES + NUMBER LINE -->
<div class="drawing-toolbar" id="drawingToolbar">
    <!-- MOVE HANDLE FOR DRAGGING -->
    <div class="toolbar-move-handle" id="toolbarMoveHandle" title="Araç çubuğunu taşı">
        <i class="fas fa-grip-vertical"></i>
    </div>

    <!-- Basic Drawing Tools -->
    <div class="tool-group">
        <button class="drawing-tool active" id="penTool" onclick="selectTool('pen')" title="Kalem (P)">
            <i class="fas fa-pen"></i>
        </button>
        <button class="drawing-tool" id="eraserTool" onclick="selectTool('eraser')" title="Silgi (E)">
            <i class="fas fa-eraser"></i>
        </button>
        <button class="drawing-tool" id="highlightTool" onclick="selectTool('highlight')" title="Fosforlu Kalem (H)">
            <i class="fas fa-highlighter"></i>
        </button>
        <button class="drawing-tool" id="handTool" onclick="selectTool('hand')" title="El (G)">
            <i class="fas fa-hand-paper"></i>
        </button>
        <button class="drawing-tool" id="textTool" onclick="selectTool('text')" title="Metin (T)">
            <i class="fas fa-font"></i>
        </button>
    </div>

    <!-- Selection Tools -->
    <div class="tool-group">
        <button class="drawing-tool" id="rectSelectTool" onclick="selectTool('rectSelect')" title="Dikdörtgen Seçim (S)">
            <i class="fas fa-vector-square"></i>
        </button>
        <button class="drawing-tool" id="lassoTool" onclick="selectTool('lasso')" title="Lasso Seçim (L)">
            <i class="fas fa-bezier-curve"></i>
        </button>
        <button class="drawing-tool" id="selectDeleteTool" onclick="selectTool('selectDelete')" title="Seçerek Sil">
            <i class="fas fa-trash-alt"></i>
        </button>
        <button class="drawing-tool" id="selectAllTool" onclick="selectAllDrawings()" title="Tümünü Seç (Ctrl+A)">
            <i class="fas fa-check-square"></i>
        </button>
        <button class="drawing-tool" id="deleteSelectedTool" onclick="deleteSelectedDrawings()" title="Seçilenleri Sil (Delete)">
            <i class="fas fa-trash"></i>
        </button>
        <button class="drawing-tool" id="screenshotTool" onclick="selectTool('screenshot')" title="Ekran Alıntısı (C)">
            <i class="fas fa-camera"></i>
        </button>
        <button class="drawing-tool" id="measureTool" onclick="selectTool('measure')" title="Ölçüm (M)">
            <i class="fas fa-ruler"></i>
        </button>
        <button class="drawing-tool" id="numberlineTool" onclick="selectTool('numberline')" title="Sayı Doğrusu (N)">
            <i class="fas fa-grip-lines"></i>
        </button>
    </div>

    <!-- Basic Shapes -->
    <div class="tool-group">
        <button class="drawing-tool" id="lineTool" onclick="selectTool('line')" title="Çizgi">
            <i class="fas fa-minus"></i>
        </button>
        <button class="drawing-tool" id="dashedLineTool" onclick="selectTool('dashedLine')" title="Kesikli Çizgi">
            <i class="fas fa-grip-lines"></i>
        </button>
        <button class="drawing-tool" id="arrowTool" onclick="selectTool('arrow')" title="Ok">
            <i class="fas fa-arrow-right"></i>
        </button>
        <button class="drawing-tool" id="straightLineTool" onclick="selectTool('straightLine')" title="Doğru (↔)">
            <span style="font-size: 12px;">↔</span>
        </button>
        <button class="drawing-tool" id="rectangleTool" onclick="selectTool('rectangle')" title="Dikdörtgen">
            <i class="fas fa-square"></i>
        </button>
        <button class="drawing-tool" id="circleTool" onclick="selectTool('circle')" title="Daire">
            <i class="fas fa-circle"></i>
        </button>
        <button class="drawing-tool" id="ellipseTool" onclick="selectTool('ellipse')" title="Elips">
            <i class="fas fa-circle" style="transform: scaleX(0.7);"></i>
        </button>
    </div>

    <!-- Geometric Shapes -->
    <div class="tool-group">
        <button class="drawing-tool" id="triangleTool" onclick="selectTool('triangle')" title="Üçgen">
            <span style="font-size: 9px;">▲</span>
        </button>
        <button class="drawing-tool" id="straightLineTool" onclick="selectTool('straightLine')" title="Doğru (↔)">
            <span style="font-size: 12px;">↔</span>
        </button>
        <button class="drawing-tool" id="pentagonTool" onclick="selectTool('pentagon')" title="Beşgen">
            <span style="font-size: 9px;">⬟</span>
        </button>
        <button class="drawing-tool" id="hexagonTool" onclick="selectTool('hexagon')" title="Altıgen">
            <span style="font-size: 9px;">⬢</span>
        </button>
        <button class="drawing-tool" id="heptagonTool" onclick="selectTool('heptagon')" title="Yedigen">
            <span style="font-size: 9px;">⬢</span>
        </button>
        <button class="drawing-tool" id="crescentTool" onclick="selectTool('crescent')" title="Hilal">
            <i class="fas fa-moon"></i>
        </button>
        <button class="drawing-tool" id="starTool" onclick="selectTool('star')" title="Yıldız">
            <i class="fas fa-star"></i>
        </button>
    </div>

    <!-- Complex Shapes -->
    <div class="tool-group">
        <button class="drawing-tool" id="trapezoidTool" onclick="selectTool('trapezoid')" title="Yamuk">
            <span style="font-size: 7px;">⏢</span>
        </button>
        <button class="drawing-tool" id="parallelogramTool" onclick="selectTool('parallelogram')" title="Paralelkenar">
            <span style="font-size: 9px;">▱</span>
        </button>
        <button class="drawing-tool" id="deltoidTool" onclick="selectTool('deltoid')" title="Deltoid">
            <span style="font-size: 9px;">◊</span>
        </button>
        <button class="drawing-tool" id="cubeTool" onclick="selectTool('cube')" title="Küp">
            <span style="font-size: 9px;">⬜</span>
        </button>
        <button class="drawing-tool" id="coneTool" onclick="selectTool('cone')" title="Koni">
            <span style="font-size: 9px;">🔺</span>
        </button>
        <button class="drawing-tool" id="cylinderTool" onclick="selectTool('cylinder')" title="Silindir">
            <span style="font-size: 9px;">⬭</span>
        </button>
    </div>

    <!-- Prism Shapes -->
    <div class="tool-group">
        <button class="drawing-tool" id="triangularPrismTool" onclick="selectTool('triangularPrism')" title="Üçgen Prizma">
            <span style="font-size: 7px;">△</span>
        </button>
        <button class="drawing-tool" id="rectangularPrismTool" onclick="selectTool('rectangularPrism')" title="Dikdörtgen Prizma">
            <span style="font-size: 7px;">▭</span>
        </button>
    </div>

    <!-- Advanced Controls -->
    <div class="advanced-controls">
        <label style="color: rgba(255,255,255,0.8); font-size: 9px;">Kalınlık:</label>
        <input type="range" class="brush-size-slider" id="brushSizeSlider" min="1" max="20" value="1" oninput="setBrushSize(this.value)">
        <div class="brush-size-display" id="brushSizeDisplay">1px</div>
    </div>

    <div class="advanced-controls">
        <label style="color: rgba(255,255,255,0.8); font-size: 9px;">Şeffaflık:</label>
        <input type="range" class="opacity-slider" id="opacitySlider" min="10" max="100" value="100" oninput="setOpacity(this.value)">
        <div class="brush-size-display" id="opacityDisplay">100%</div>
    </div>

    <!-- Grid Controls -->
    <div class="tool-group">
        <button class="drawing-tool" id="gridTool" onclick="toggleGrid()" title="Izgara">
            <i class="fas fa-th"></i>
        </button>
        <button class="drawing-tool" id="snapTool" onclick="toggleSnap()" title="Yakalama">
            <i class="fas fa-magnet"></i>
        </button>
    </div>

    <!-- Color Palette -->
    <div class="tool-group">
        <div class="color-picker active" style="background: #ff0000;" onclick="selectColor('#ff0000')" title="Kırmızı"></div>
        <div class="color-picker" style="background: #00ff00;" onclick="selectColor('#00ff00')" title="Yeşil"></div>
        <div class="color-picker" style="background: #0000ff;" onclick="selectColor('#0000ff')" title="Mavi"></div>
        <div class="color-picker" style="background: #000000;" onclick="selectColor('#000000')" title="Siyah"></div>
        <div class="color-picker" style="background: #ffff00;" onclick="selectColor('#ffff00')" title="Sarı"></div>
        <div class="color-picker" style="background: #800080;" onclick="selectColor('#800080')" title="Mor"></div>
        <div class="color-picker" style="background: #ffa500;" onclick="selectColor('#ffa500')" title="Turuncu"></div>
        <div class="color-picker" style="background: #ffffff;" onclick="selectColor('#ffffff')" title="Beyaz"></div>
    </div>

    <!-- Action Tools -->
    <div class="tool-group">
        <button class="drawing-tool" onclick="undoDrawing()" title="Geri Al (Ctrl+Z)">
            <i class="fas fa-undo"></i>
        </button>
        <button class="drawing-tool" onclick="redoDrawing()" title="İleri Al (Ctrl+Y)">
            <i class="fas fa-redo"></i>
        </button>
        <button class="drawing-tool" onclick="clearAllDrawing()" title="Temizle">
            <i class="fas fa-trash"></i>
        </button>
        <button class="drawing-tool" onclick="saveDrawing()" title="Kaydet (Ctrl+S)">
            <i class="fas fa-save"></i>
        </button>
    </div>

    <!-- Multi-Selection Tools -->
    <div class="tool-group">
        <button class="drawing-tool" onclick="selectAllDrawings()" title="Tümünü Seç (Ctrl+A)">
            <i class="fas fa-mouse-pointer"></i>
            <span class="selection-count" id="selectionCount" style="display: none;">0</span>
        </button>
        <button class="drawing-tool" onclick="deleteSelectedDrawings()" title="Seçilenleri Sil (Delete)">
            <i class="fas fa-trash-alt"></i>
        </button>
        <button class="drawing-tool" onclick="copySelectedDrawings()" title="Kopyala (Ctrl+C)">
            <i class="fas fa-copy"></i>
        </button>
        <button class="drawing-tool" onclick="pasteDrawings()" title="Yapıştır (Ctrl+V)">
            <i class="fas fa-paste"></i>
        </button>
    </div>
</div>

<!-- Main Content -->
<main class="main-content" id="mainContent">
    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-content">
            <h1 class="welcome-title">BELGESELSEMO PDF VIEWER</h1>
            <p class="welcome-subtitle">%40 BOLT.NEW, %60 REPLIT AI sayesinde BELGESELSEMO tarafından hazırlanmıştır...</p>

            <div class="features-grid">
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-file-upload"></i></div>
                    <div class="feature-title">Dosya Yükleme</div>
                    <div class="feature-desc">Yerel dosya seçimi, sürükle-bırak ve uzak URL ile PDF açma. Çoklu format desteği ve anlık yükleme.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-sticky-note"></i></div>
                    <div class="feature-title">Not & Yer İmleri</div>
                    <div class="feature-desc">Kategorili not alma, favori işaretleme, yer imi oluşturma ve sürükle-bırak ile dosya yönetimi.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-layer-group"></i></div>
                    <div class="feature-title">Popup Menüler</div>
                    <div class="feature-desc">Bilgi popup'ı, kısayollar rehberi, son açılan dosyalar ve sayfa önizleme paneli ile hızlı erişim.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-play-circle"></i></div>
                    <div class="feature-title">Otomatik Kaydırma</div>
                    <div class="feature-desc">Ayarlanabilir hız ile otomatik sayfa kaydırma, durdurup devam ettirme ve yumuşak geçişler.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-paint-brush"></i></div>
                    <div class="feature-title">Çizim Araçları</div>
                    <div class="feature-desc">25+ geometrik şekil, fırça, kalem, silgi, metin araçları ve gelişmiş seçim özellikleri ile tam çizim desteği.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-search"></i></div>
                    <div class="feature-title">Arama & Döndürme</div>
                    <div class="feature-desc">Hızlı metin arama, sonuç önizleme, sayfa döndürme ve 360° görüntü manipülasyonu.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-mouse-pointer"></i></div>
                    <div class="feature-title">Sağ Tık Menüsü</div>
                    <div class="feature-desc">Bağlamsal sağ tık menüsü ile hızlı işlemler, kopyalama, yapıştırma ve gelişmiş seçenekler.</div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon"><i class="fas fa-search-plus"></i></div>
                    <div class="feature-title">Zoom Araçları</div>
                    <div class="feature-desc">Esnek zoom seviyeleri, sayfa genişliğine sığdırma, tam ekran modu ve hassas büyütme kontrolleri.</div>
                </div>
            </div>

            <div class="start-buttons">
                <button class="btn btn-primary" onclick="openFilePicker()">
                    <i class="fas fa-file-upload"></i>
                    Dosya Seç
                </button>
                <button class="btn btn-secondary" onclick="showUrlPopup()">
                    <i class="fas fa-link"></i>
                    URL'den Aç
                </button>
                <button class="btn btn-outline" onclick="showRecentFiles(event)" id="recentFilesBtn">
                    <i class="fas fa-history"></i>
                    Son Açılanlar
                </button>
            </div>
        </div>
    </div>

    <!-- PDF Container -->
    <div class="pdf-container" id="pdfContainer">
        <!-- PDF pages will be inserted here -->
    </div>
</main>

<!-- Enhanced Footer -->
<footer class="footer">
    <div class="footer-left">
        <div class="footer-icon" onclick="goHome()" title="Ana Sayfa">
            <i class="fas fa-home"></i>
        </div>
        <div class="footer-icon" onclick="showRecentFiles(event)" title="Son Açılanlar">
            <i class="fas fa-history"></i>
        </div>
        <div class="footer-icon" onclick="showNotesModal(event)" title="Not Listesi">
            <i class="fas fa-sticky-note"></i>
        </div>
        <div class="footer-icon" onclick="toggleThumbnailPanel(event)" title="Sayfa Önizlemeleri">
            <i class="fas fa-th-large"></i>
        </div>
    </div>

    <div class="footer-center">
        <div class="page-nav">
            <div class="page-icon" onclick="goToFirstPage()" title="İlk Sayfa">
                <i class="fas fa-angle-double-left"></i>
            </div>
            <div class="page-icon" onclick="previousPage()" title="Önceki Sayfa">
                <i class="fas fa-angle-left"></i>
            </div>
            <input type="number" class="page-input" id="pageInput" min="1" value="1" onchange="handlePageInputChange()">
            <span class="page-info" id="pageInfo">/ 0</span>
            <div class="page-icon" onclick="nextPage()" title="Sonraki Sayfa">
                <i class="fas fa-angle-right"></i>
            </div>
            <div class="page-icon" onclick="goToLastPage()" title="Son Sayfa">
                <i class="fas fa-angle-double-right"></i>
            </div>
        </div>
    </div>

    <div class="footer-right">
        <div class="footer-icon" onclick="toggleDrawingTools()" title="Çizim Araçları">
            <i class="fas fa-paint-brush"></i>
        </div>
        <div class="footer-icon" id="autoScrollIcon" onclick="toggleAutoScroll()" title="Otomatik Kaydırma">
            <i class="fas fa-play"></i>
        </div>
        <div class="footer-icon" onclick="toggleZoomControls()" title="Zoom">
            <i class="fas fa-search-plus"></i>
        </div>
    </div>
</footer>

<!-- Auto Scroll Speed Control -->
<div class="auto-scroll-container" id="autoScrollContainer">
    <button class="scroll-speed-btn" onclick="decreaseScrollSpeed()" title="Yavaşlat">
        <i class="fas fa-minus"></i>
    </button>
    <input type="range" class="scroll-speed-slider" id="scrollSpeedSlider" min="1" max="10" value="3" oninput="setScrollSpeed(this.value)">
    <button class="scroll-speed-btn" onclick="increaseScrollSpeed()" title="Hızlandır">
        <i class="fas fa-plus"></i>
    </button>
    <div class="scroll-speed-value" id="scrollSpeedValue">3x</div>
    <button class="scroll-speed-btn" onclick="toggleAutoScroll()" title="Durdur">
        <i class="fas fa-stop"></i>
    </button>
</div>

<!-- Zoom Control -->
<div class="zoom-container" id="zoomContainer">
    <button class="zoom-btn" onclick="zoomOut()" title="Uzaklaştır">
        <i class="fas fa-minus"></i>
    </button>
    <input type="range" class="zoom-slider" id="zoomSlider" min="25" max="500" value="250" oninput="setZoom(this.value)">
    <button class="zoom-btn" onclick="zoomIn()" title="Yakınlaştır">
        <i class="fas fa-plus"></i>
    </button>
    <div class="zoom-value" id="zoomValue">250%</div>
    <button class="zoom-btn" onclick="toggleZoomControls()" title="Kapat">
        <i class="fas fa-times"></i>
    </button>
</div>

<!-- RIGHT CLICK CONTEXT MENU -->
<div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="contextMenuAction('copy')">
        <i class="fas fa-copy"></i>
        <span>Kopyala</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('selectAll')">
        <i class="fas fa-select-all"></i>
        <span>Tümünü Seç</span>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuAction('zoomIn')">
        <i class="fas fa-search-plus"></i>
        <span>Yakınlaştır</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('zoomOut')">
        <i class="fas fa-search-minus"></i>
        <span>Uzaklaştır</span>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuAction('rotateLeft')">
        <i class="fas fa-undo"></i>
        <span>Sola Döndür</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('rotateRight')">
        <i class="fas fa-redo"></i>
        <span>Sağa Döndür</span>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuAction('fullscreen')">
        <i class="fas fa-expand"></i>
        <span>Tam Ekran</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('printPage')">
        <i class="fas fa-print"></i>
        <span>Yazdır</span>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuAction('saveImage')">
        <i class="fas fa-download"></i>
        <span>Resim Olarak Kaydet</span>
    </div>
</div>

<!-- Theme Selection Popup -->
<div class="theme-popup" id="themePopup">
    <div class="theme-popup-content">
        <div class="theme-popup-header">
            <h2 class="theme-popup-title">Tema Seç</h2>
            <button class="theme-close-btn" onclick="hideThemePopup()">&times;</button>
        </div>

        <div class="theme-grid">
            <div class="theme-option active" data-theme="default" onclick="selectTheme('default')" title="Varsayılan"></div>
            <div class="theme-option" data-theme="forest" onclick="selectTheme('forest')" title="Orman"></div>
            <div class="theme-option" data-theme="sunset" onclick="selectTheme('sunset')" title="Gün Batımı"></div>
            <div class="theme-option" data-theme="ocean" onclick="selectTheme('ocean')" title="Okyanus"></div>
            <div class="theme-option" data-theme="purple" onclick="selectTheme('purple')" title="Mor"></div>
            <div class="theme-option" data-theme="dark" onclick="selectTheme('dark')" title="Karanlık"></div>
            <div class="theme-option" data-theme="golden" onclick="selectTheme('golden')" title="Altın"></div>
            <div class="theme-option" data-theme="emerald" onclick="selectTheme('emerald')" title="Zümrüt"></div>
            <div class="theme-option" data-theme="crimson" onclick="selectTheme('crimson')" title="Kızıl"></div>
            <div class="theme-option" data-theme="royal" onclick="selectTheme('royal')" title="Kraliyet"></div>
        </div>

        <div class="custom-theme-section">
            <h3 class="custom-theme-title">Özel Tema</h3>
            <div class="custom-theme-controls">
                <div class="color-input-group">
                    <label class="color-input-label">Başlık</label>
                    <input type="color" class="color-input" id="headerColor" value="#2c3e50">
                </div>
                <div class="color-input-group">
                    <label class="color-input-label">Vurgu</label>
                    <input type="color" class="color-input" id="accentColor" value="#3498db">
                </div>
                <button class="apply-custom-theme" onclick="applyCustomTheme()">Özel Temayı Uygula</button>
            </div>
        </div>
    </div>
</div>

<!-- Info Popup -->
<div class="info-popup" id="infoPopup">
    <div class="info-content">
        <div class="popup-header">
            <h2 class="popup-title">PDF Görüntüleyici Bilgisi</h2>
            <button class="theme-close-btn" onclick="hideInfoPopup()">&times;</button>
        </div>
        <div class="popup-content-scrollable">
            <div class="popup-text">
                Bu PDF görüntüleyici, PDF belgelerini doğrudan tarayıcınızda Ultra HD kalitede görüntülemenizi sağlar. Sayfalar arasında gezilebilir, yakınlaştırıp uzaklaştırabilir, ve tercihlerinize göre ayarlayabilirsiniz.
            </div>
            <div class="popup-text">
                Bu HTML tabanlı BELGESELSEMO PDF VIEWER uygulaması AI teknolojileri kullanılarak geliştirilmiş ve BELGESELSEMO tarafından optimize edilmiştir.
            </div>
            <h3 style="color: var(--accent-color); margin: 20px 0 15px 0; font-size: 1.3rem;">Ultra Gelişmiş Seçim ve Manipülasyon</h3>
            <div class="popup-text">
                <strong>Dikdörtgen Seçim:</strong> Fareyle dikdörtgen seçim yapın, seçili alanı taşıyın, 360° döndürün, 8 noktadan boyutlandırın.<br><br>
                <strong>Lasso Seçim:</strong> Serbest form seçim yapın, aynı manipülasyon özelliklerini kullanın.<br><br>
                <strong>Ekran Alıntısı:</strong> Seçim alanını otomatik olarak panoya kopyalama (Ctrl+V ile yapıştırabilirsiniz).<br><br>
                <strong>360° Döndürme:</strong> Seçili alanları gerçek zamanlı döndürme, Ctrl ile 15° artışlarla.<br><br>
                <strong>8-Nokta Boyutlandırma:</strong> 8 resize handle'ı ile hassas boyutlandırma.<br><br>
                <strong>Otomatik Zoom:</strong> Masaüstünde %250, mobilde %102 otomatik zoom ayarı.<br><br>
                <strong>Kalıcı Çizimler:</strong> Tüm çizimler sayfa değişimlerinde otomatik olarak korunur.<br><br>
                <strong>Gerçek Zamanlı:</strong> Tüm manipülasyonlar gerçek zamanlı olarak görüntülenir.
            </div>
            <h3 style="color: var(--accent-color); margin: 20px 0 15px 0; font-size: 1.3rem;">Gelişmiş Kontroller</h3>
            <div class="popup-text">
                <strong>S:</strong> Dikdörtgen seçim aracını aktif et<br>
                <strong>L:</strong> Lasso seçim aracını aktif et<br>
                <strong>C:</strong> Ekran alıntısı aracını aktif et<br>
                <strong>N:</strong> Sayı doğrusu aracını aktif et<br>
                <strong>Ctrl+A:</strong> Tüm çizimleri seç<br>
                <strong>Delete:</strong> Seçili çizimleri sil<br>
                <strong>Sürükle:</strong> Seçili alanı taşı<br>
                <strong>Shift+Sürükle:</strong>Orantılı boyutlandırma<br>
                <strong>Ctrl+Döndür:</strong> 15° artışlarla döndürme
            </div>
        </div>
        <div class="popup-footer">
            BELGESELSEMO.COM.TR
        </div>
    </div>
</div>

<!-- Hotkey Popup -->
<div class="hotkey-popup" id="hotkeyPopup">
    <div class="hotkey-content">
        <div class="popup-header">
            <h2 class="popup-title">Klavye Kısayolları</h2>
            <button class="theme-close-btn" onclick="hideHotkeyPopup()">&times;</button>
        </div>
        <div class="popup-content-scrollable">
            <table class="hotkey-table">
                <thead>
                <tr>
                    <th>İşlem</th>
                    <th>Kısayol</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Önceki Sayfa</td>
                    <td><span class="hotkey-key">←</span> veya <span class="hotkey-key">PageUp</span></td>
                </tr>
                <tr>
                    <td>Sonraki Sayfa</td>
                    <td><span class="hotkey-key">→</span> veya <span class="hotkey-key">PageDown</span></td>
                </tr>
                <tr>
                    <td>İlk Sayfa</td>
                    <td><span class="hotkey-key">Home</span></td>
                </tr>
                <tr>
                    <td>Son Sayfa</td>
                    <td><span class="hotkey-key">End</span></td>
                </tr>
                <tr>
                    <td>Yakınlaştır</td>
                    <td><span class="hotkey-key">+</span> veya <span class="hotkey-key">Ctrl + Mouse Wheel</span></td>
                </tr>
                <tr>
                    <td>Uzaklaştır</td>
                    <td><span class="hotkey-key">-</span> veya <span class="hotkey-key">Ctrl + Mouse Wheel</span></td>
                </tr>
                <tr>
                    <td>Saat yönünde döndür</td>
                    <td><span class="hotkey-key">R</span></td>
                </tr>
                <tr>
                    <td>Saat yönünün tersine döndür</td>
                    <td><span class="hotkey-key">L</span></td>
                </tr>
                <tr>
                    <td>Tam Ekran</td>
                    <td><span class="hotkey-key">F</span> veya <span class="hotkey-key">F11</span></td>
                </tr>
                <tr>
                    <td>Çizim araçlarını aç/kapat</td>
                    <td><span class="hotkey-key">D</span></td>
                </tr>
                <tr>
                    <td>Dikdörtgen seçim aracını aktif et</td>
                    <td><span class="hotkey-key">S</span></td>
                </tr>
                <tr>
                    <td>Lasso seçim aracını aktif et</td>
                    <td><span class="hotkey-key">L</span></td>
                </tr>
                <tr>
                    <td>Ekran alıntısı aracını aktif et</td>
                    <td><span class="hotkey-key">C</span></td>
                </tr>
                <tr>
                    <td>Sayı doğrusu aracını aktif et</td>
                    <td><span class="hotkey-key">N</span></td>
                </tr>
                <tr>
                    <td>Tüm çizimleri seç</td>
                    <td><span class="hotkey-key">Ctrl+A</span></td>
                </tr>
                <tr>
                    <td>Seçili çizimleri sil</td>
                    <td><span class="hotkey-key">Delete</span></td>
                </tr>
                <tr>
                    <td>Seçili alanı taşı</td>
                    <td><span class="hotkey-key">Sürükle</span></td>
                </tr>
                <tr>
                    <td>Seçili alanı döndür</td>
                    <td><span class="hotkey-key">Döndürme Handle'ı</span></td>
                </tr>
                <tr>
                    <td>Seçili alanı boyutlandır</td>
                    <td><span class="hotkey-key">Köşe Handle'ları</span></td>
                </tr>
                <tr>
                    <td>Orantılı boyutlandırma</td>
                    <td><span class="hotkey-key">Shift + Sürükle</span></td>
                </tr>
                <tr>
                    <td>15° artışlarla döndürme</td>
                    <td><span class="hotkey-key">Ctrl + Döndür</span></td>
                </tr>
                <tr>
                    <td>Açık paneli kapat</td>
                    <td><span class="hotkey-key">Esc</span></td>
                </tr>
                </tbody>
            </table>
        </div>
        <div class="popup-footer">
            BELGESELSEMO.COM.TR
        </div>
    </div>
</div>

<!-- Search Modal -->
<div class="modal-overlay" id="searchModal">
    <div class="modal-content">
        <div class="theme-popup-header">
            <h2 class="theme-popup-title">PDF'de Ara</h2>
            <button class="theme-close-btn" onclick="closeSearchModal()">&times;</button>
        </div>
        <div style="margin-bottom: 20px;">
            <input type="text" style="width: 100%; padding: 12px; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 8px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 14px; outline: none;" id="searchInput" placeholder="Aramak istediğiniz kelime veya cümleyi yazın..." onkeypress="handleSearchKeyPress(event)">
        </div>
        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
            <button class="btn btn-primary" onclick="performSearch()">
                <i class="fas fa-search"></i> Ara
            </button>
            <button class="btn btn-secondary" onclick="findNext()">
                <i class="fas fa-arrow-down"></i> Sonraki
            </button>
            <button class="btn btn-secondary" onclick="findPrevious()">
                <i class="fas fa-arrow-up"></i> Önceki
            </button>
            <button class="btn btn-outline" onclick="clearSearch()">
                <i class="fas fa-times"></i> Temizle
            </button>
        </div>
        <div id="searchResults" style="display: none; max-height: 200px; overflow-y: auto; margin-top: 15px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
            <!-- Search results will be populated here -->
        </div>
    </div>
</div>

<!-- Enhanced URL Popup -->
<div class="popup-overlay hidden" id="popupOverlay">
    <div class="popup-content url-input-popup" id="popupContent">
        <div class="popup-header">
            <div class="popup-title">PDF URL'si Girin</div>
            <button class="popup-close" onclick="closePopup()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <input type="url" class="url-input" id="urlInput" placeholder="https://example.com/document.pdf" autocomplete="off" spellcheck="false">
        <div class="url-loading hidden" id="urlLoading">
            <div class="loading-spinner"></div>
            <div class="url-loading-text" id="urlLoadingText">URL analiz ediliyor...</div>
            <div class="url-progress">
                <div class="url-progress-bar" id="urlProgressBar"></div>
            </div>
        </div>
        <div class="url-status hidden" id="urlStatus">
            <div class="url-status-icon">
                <i class="fas fa-info-circle"></i>
            </div>
            <div class="url-status-text" id="urlStatusText"></div>
        </div>
        <div class="popup-buttons">
            <button class="popup-button secondary" onclick="closePopup()">İptal</button>
            <button class="popup-button primary" onclick="loadFromUrl()">Yükle</button>
        </div>
    </div>
</div>

<!-- Recent Files Modal -->
<div class="recent-files-modal" id="recentFilesModal">
    <div class="recent-files-content">
        <div class="recent-files-header">
            <h2 class="recent-files-title">Son Açılan PDF Dosyaları</h2>
            <button class="theme-close-btn" onclick="hideRecentFiles()">&times;</button>
        </div>
        <div class="recent-files-list" id="recentFilesList">
            <!-- Recent files will be populated here -->
        </div>
        <button class="clear-recent-btn" onclick="clearRecentFiles()">
            <i class="fas fa-trash"></i> Tüm Listeyi Temizle
        </button>
    </div>
</div>

<!-- Notes Modal -->
<div class="notes-modal" id="notesModal" onclick="hideNotesModal()">
    <div class="notes-container" onclick="event.stopPropagation()">
        <div class="notes-header">
            <h2 class="notes-title">
                <i class="fas fa-sticky-note" style="color: var(--accent-color);"></i>
                Not Listesi
            </h2>
            <button class="notes-close" onclick="hideNotesModal()" title="Kapat">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <div class="add-note-section">
            <div class="note-input-controls">
                <select class="note-category-select" id="noteCategory">
                    <option value="genel">📝 Genel</option>
                    <option value="onemli">⭐ Önemli</option>
                    <option value="calisma">📚 Çalışma</option>
                    <option value="is">💼 İş</option>
                </select>
                <button class="note-priority-btn" id="notePriority" onclick="toggleNotePriority()" title="Favori olarak işaretle">
                    <i class="fas fa-star"></i> Favori
                </button>
            </div>
            <div style="margin: 15px 0;"></div>
            <textarea
                    class="add-note-input"
                    id="noteInput"
                    placeholder="Yeni notunuzu buraya yazın..."
                    rows="4"
            ></textarea>
            <button class="add-note-btn" onclick="addNote()">
                <i class="fas fa-plus"></i>
                Not Ekle
            </button>
        </div>

        <div class="notes-list" id="notesList">
            <!-- Notes will be populated here -->
        </div>
    </div>
</div>

<!-- Bookmarks Panel -->
<div class="bookmarks-panel" id="bookmarksPanel">
    <div class="bookmarks-header">Yer İmleri</div>
    <div class="bookmarks-list" id="bookmarksList">
        <div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">
            Henüz yer imi eklenmemiş
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <h3>PDF Yükleniyor...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <p id="loadingText">Yükleniyor...</p>
    </div>
</div>

<!-- Toast Container -->
<div class="toast" id="toast"></div>

<!-- Clipboard Overlay -->
<div class="clipboard-overlay" id="clipboardOverlay">
    <div style="font-size: 18px; margin-bottom: 10px;">
        <i class="fas fa-clipboard-check" style="margin-right: 10px; color: var(--accent-color);"></i>
        Panoya Kopyalandı!
    </div>
    <div style="font-size: 14px; opacity: 0.8;">
        Ctrl+V ile istediğiniz yere yapıştırabilirsiniz
    </div>
</div>

<!-- Thumbnail Panel -->
<div class="thumbnail-panel" id="thumbnailPanel">
    <div class="thumbnail-header">
        <div>
            <i class="fas fa-th-large" style="margin-right: 10px;"></i>
            Sayfa Önizlemeleri
        </div>
        <button class="thumbnail-close-btn" onclick="closeThumbnailPanel()" title="Kapat">
            <i class="fas fa-times"></i>
        </button>
    </div>
    <div class="thumbnail-grid" id="thumbnailGrid">
        <!-- Thumbnails will be generated here -->
    </div>
    <div class="thumbnail-footer">
        BELGESELSEMO.COM.TR
    </div>
</div>

<!-- Hidden File Input -->
<input type="file" id="fileInput" accept=".pdf" style="display: none;" onchange="handleFileSelect(event)">

<script>
    // PDF.js configuration for ULTRA HIGH QUALITY
        if (typeof window !== 'undefined' && window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // Global Variables
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let scale = 2.5; // Default desktop scale
        let rotation = 0;
        let pageCache = new Map();
        let visiblePageObserver = null;
        let searchResults = [];
        let searchCache = new Map();
        let searchWorker = null;
        let notes = [];
        let currentSearchIndex = -1;
        let currentTheme = 'default';
        let bookmarks = [];
        let recentFiles = [];

        // ENHANCED Auto-scroll variables - PÜRÜZSÜZ KAYDIRMA İÇİN
        let isAutoScrolling = false;
        let autoScrollInterval = null;
        let scrollSpeed = 3;
        let smoothScrollFrame = null; // requestAnimationFrame için

        // ULTRA ENHANCED Drawing variables
        let isDrawingMode = false;
        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = '#ff0000';
        let brushSize = 1;
        let currentOpacity = 100;
        let drawingCanvases = new Map();
        let drawingContexts = new Map();
        let undoStack = {};
        let redoStack = {};
        let selectedDrawings = new Set();
        let copiedDrawings = [];
        let isGridEnabled = false;
        let isSnapEnabled = false;
        let measurements = new Map();
        let textEditors = new Map();
        let numberLines = new Map();

        // ULTRA ENHANCED SELECTION AND MANIPULATION VARIABLES
        let activeSelections = new Map();
        let isSelecting = false;
        let selectionStart = null;
        let highlights = new Map();
        let isManipulating = false;
        let manipulationData = null;
        let manipulationStartPos = null;
        let manipulationStartSize = null;
        let manipulationStartRotation = 0;
        let currentManipulationHandle = null;

        let manipulationCanvas = null;
        let capturedImageData = null;
        let originalCanvasState = null;
        let isFlippedHorizontal = false;
        let isFlippedVertical = false;
        let currentRotation = 0;

        // Toolbar dragging variables
        let isDraggingToolbar = false;
        let toolbarDragOffset = { x: 0, y: 0 };

        // Current file info for recent files
        let currentFileInfo = null;

        // Performance optimization variables
        let lastRenderTime = 0;
        let renderQueue = [];
        let isRendering = false;

        // PERSISTENT DRAWINGS STORAGE
        let persistentDrawings = new Map(); // pageNum -> imageData

        // ENHANCED COPY/PASTE SYSTEM FOR DRAWINGS
        let clipboardData = null;
        let allPageDrawings = new Map(); // pageNum -> drawings array

        // ENHANCED MEASUREMENT SYSTEM
        let measurementPoints = [];
        let currentMeasurement = null;
        let activeMeasurements = new Map();

        // CORS Proxies for URL loading
        const corsProxies = [
            'https://belgeselsemo.com.tr/php/cors.php?url=', // Default proxy
            'https://api.allorigins.win/raw?url=',
            'https://api.codetabs.com/v1/proxy/?quest=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/',
            'https://api.cors.lol/?url='
        ];

        /**
         * Analyze PDF URL to detect special cases (Archive.org, Dropbox, Google Drive, etc.)
         */
        async function analyzePDFUrl(url) {
            try {
                console.log('URL analiz ediliyor:', url);
                
                // Google Drive handling
                if (url.includes('drive.google.com')) {
                    if (url.includes('/file/d/')) {
                        const fileId = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/)?.[1];
                        if (fileId) {
                            const directUrl = `https://drive.google.com/uc?id=${fileId}&export=download`;
                            console.log('Google Drive PDF linki oluşturuldu:', directUrl);
                            return directUrl;
                        }
                    } else if (url.includes('uc?id=')) {
                        console.log('Google Drive direkt download linki algılandı');
                        return url;
                    }
                }
                
                // Dropbox handling - convert to direct download
                if (url.includes('dropbox.com')) {
                    let processedUrl = url;
                    if (url.includes('?dl=0')) {
                        processedUrl = url.replace('?dl=0', '?dl=1');
                    } else if (!url.includes('?dl=1')) {
                        processedUrl = url + (url.includes('?') ? '&dl=1' : '?dl=1');
                    }
                    
                    // Convert to direct content URL
                    if (url.includes('www.dropbox.com')) {
                        processedUrl = processedUrl.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
                    }
                    console.log('Dropbox PDF linki işlendi:', processedUrl);
                    return processedUrl;
                }
                
                // Archive.org handling
                if (url.includes('archive.org')) {
                    console.log('Archive.org PDF linki algılandı');
                    return url; // Archive.org URLs usually work directly
                }
                
                // TÜBİTAK handling
                if (url.includes('tubitak.gov.tr') || url.includes('services.tubitak.gov.tr')) {
                    console.log('TÜBİTAK PDF linki algılandı');
                    return url; // Keep original URL
                }
                
                // OneDrive handling
                if (url.includes('onedrive.live.com') || url.includes('1drv.ms')) {
                    if (url.includes('?') && !url.includes('download=1')) {
                        const processedUrl = url + '&download=1';
                        console.log('OneDrive PDF linki işlendi:', processedUrl);
                        return processedUrl;
                    }
                }
                
                // Direct PDF URL detection
                if (url.toLowerCase().includes('.pdf')) {
                    console.log('Direkt PDF linki algılandı');
                    return url;
                }
                
                // Check if URL might be a download link that results in PDF
                if (url.includes('export=download') || 
                    url.includes('download=1') || 
                    url.includes('attachment=1') ||
                    url.match(/\.(pdf|PDF)(\?|$)/)) {
                    console.log('PDF indirme linki algılandı');
                    return url;
                }
                
                // If not recognized, try to follow redirects
                console.log('URL türü tanınmadı, yönlendirmeler takip ediliyor');
                return await followRedirectsForPDF(url);
                
            } catch (error) {
                console.log('URL parsing error:', error);
            }
            return url;
        }

        /**
         * Follow redirects to find the final PDF URL
         */
        async function followRedirectsForPDF(url) {
            console.log('Yönlendirmeler takip ediliyor:', url);
            let currentUrl = url;
            let redirectCount = 0;
            const maxRedirects = 10;
            
            while (redirectCount < maxRedirects) {
                try {
                    // Try with multiple proxies for redirect following
                    for (let proxyIndex = 0; proxyIndex < corsProxies.length; proxyIndex++) {
                        try {
                            const proxyUrl = corsProxies[proxyIndex] + encodeURIComponent(currentUrl);
                            console.log(`Proxy ${proxyIndex + 1} ile yönlendirme kontrolü:`, currentUrl);
                            
                            const response = await fetch(proxyUrl, {
                                method: 'HEAD',
                                headers: {
                                    'Accept': 'application/pdf,application/octet-stream,*/*',
                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                                }
                            });
                            
                            if (response.ok) {
                                const contentType = response.headers.get('content-type');
                                const contentDisposition = response.headers.get('content-disposition');
                                
                                // Check if it's a PDF or download
                                if ((contentType && (contentType.includes('application/pdf') || 
                                     contentType.includes('application/octet-stream'))) ||
                                    (contentDisposition && contentDisposition.includes('attachment')) ||
                                    currentUrl.toLowerCase().includes('.pdf')) {
                                    console.log('PDF bulundu:', currentUrl);
                                    return currentUrl;
                                }
                                
                                // Check for redirects
                                const finalUrl = response.url;
                                if (finalUrl && finalUrl !== currentUrl && finalUrl !== proxyUrl) {
                                    // Extract actual URL from proxy response
                                    let extractedUrl = finalUrl;
                                    if (finalUrl.includes(corsProxies[proxyIndex])) {
                                        extractedUrl = decodeURIComponent(finalUrl.replace(corsProxies[proxyIndex], ''));
                                    }
                                    
                                    if (extractedUrl !== currentUrl) {
                                        console.log('Yönlendirme bulundu:', extractedUrl);
                                        currentUrl = extractedUrl;
                                        redirectCount++;
                                        break; // Try next redirect
                                    }
                                }
                            }
                        } catch (proxyError) {
                            console.log(`Proxy ${proxyIndex + 1} yönlendirme hatası:`, proxyError);
                            continue;
                        }
                    }
                    
                    // If we've tried all proxies without finding a redirect, break
                    if (redirectCount === 0) break;
                    
                } catch (error) {
                    console.log('Redirect follow error:', error);
                    break;
                }
            }
            
            console.log('Son URL:', currentUrl);
            return currentUrl;
        }

        /**
         * Try loading PDF with different CORS proxies
         */
        async function loadPDFWithProxies(url) {
            const loadingText = document.getElementById('urlLoadingText');
            const progressBar = document.getElementById('urlProgressBar');
            
            console.log('PDF yükleme işlemi başlatılıyor:', url);
            
            // Enhanced direct URL attempt with better headers
            try {
                loadingText.textContent = 'Direkt bağlantı deneniyor...';
                progressBar.style.width = '40%';
                
                // Test with HEAD request first
                const testResponse = await fetch(url, { 
                    method: 'HEAD',
                    headers: {
                        'Accept': 'application/pdf,application/octet-stream,*/*',
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });
                
                if (testResponse.ok) {
                    const contentType = testResponse.headers.get('content-type');
                    console.log('Content-Type:', contentType);
                    
                    if (contentType && (contentType.includes('application/pdf') || 
                        contentType.includes('application/octet-stream'))) {
                        showUrlStatus('success', 'Direkt bağlantı başarılı!', 'check-circle');
                        await loadPDFDocument(url);
                        return;
                    }
                }
                
                loadingText.textContent = 'Direkt bağlantı başarısız, proxy sunucuları deneniyor...';
                progressBar.style.width = '50%';
                
            } catch (directError) {
                console.log('Direkt yükleme başarısız:', directError);
                loadingText.textContent = 'CORS engeli, proxy sunucuları kullanılıyor...';
            }
            
            // Try with each proxy
            for (let i = 0; i < corsProxies.length; i++) {
                try {
                    const proxyUrl = corsProxies[i] + encodeURIComponent(url);
                    
                    loadingText.textContent = `Proxy ${i + 1}/${corsProxies.length} deneniyor...`;
                    progressBar.style.width = `${50 + (i * 40 / corsProxies.length)}%`;
                    
                    console.log(`Proxy ${i + 1} deneniyor:`, corsProxies[i]);
                    showUrlStatus('warning', `Proxy ${i + 1}: ${corsProxies[i].split('/')[2]}`, 'server');
                    
                    // Test proxy with HEAD request
                    const proxyTestResponse = await fetch(proxyUrl, { 
                        method: 'HEAD',
                        headers: {
                            'Accept': 'application/pdf,application/octet-stream,*/*'
                        }
                    });
                    
                    if (proxyTestResponse.ok) {
                        console.log(`Proxy ${i + 1} test başarılı, PDF yükleniyor...`);
                        await loadPDFDocument(proxyUrl);
                        showUrlStatus('success', `Proxy ${i + 1} ile başarılı!`, 'check-circle');
                        return;
                    }
                    
                } catch (proxyError) {
                    console.log(`Proxy ${i + 1} başarısız:`, proxyError);
                    showUrlStatus('warning', `Proxy ${i + 1} başarısız, sonraki deneniyor...`, 'exclamation-triangle');
                    continue;
                }
            }
            
            // Final attempt: try direct loading anyway
            try {
                console.log('Tüm proxy\'ler başarısız, son deneme olarak direkt yükleme...');
                showUrlStatus('warning', 'Son deneme: direkt yükleme...', 'exclamation-triangle');
                await loadPDFDocument(url);
                showUrlStatus('success', 'Direkt yükleme beklenmedik şekilde başarılı!', 'check-circle');
                return;
            } catch (finalError) {
                console.log('Son deneme de başarısız:', finalError);
            }
            
            throw new Error('Tüm yükleme yöntemleri başarısız. URL erişilebilir değil veya PDF formatında değil.');
        }

        /**
         * Show URL processing status
         */
        function showUrlStatus(type, message, iconClass) {
            const status = document.getElementById('urlStatus');
            const statusText = document.getElementById('urlStatusText');
            const statusIcon = status.querySelector('.url-status-icon i');
            
            status.className = `url-status ${type}`;
            statusText.textContent = message;
            statusIcon.className = `fas fa-${iconClass}`;
            status.classList.remove('hidden');
        }

        /**
         * Show URL popup
         */
        function showUrlPopup() {
            const popup = document.getElementById('popupOverlay');
            const urlInput = document.getElementById('urlInput');
            const urlLoading = document.getElementById('urlLoading');
            const urlStatus = document.getElementById('urlStatus');
            
            popup.classList.remove('hidden');
            urlInput.value = '';
            urlInput.focus();
            urlLoading.classList.add('hidden');
            urlStatus.classList.add('hidden');
            
            // Enhanced paste support
            setupUrlInputPasteSupport();
            
            // Setup global Ctrl+V listener for popup
            setupGlobalPasteListener();
        }

        /**
         * Setup enhanced paste support for URL input
         */
        function setupUrlInputPasteSupport() {
            const urlInput = document.getElementById('urlInput');
            
            // Remove existing event listeners to avoid duplicates
            urlInput.removeEventListener('paste', handleUrlPaste);
            urlInput.removeEventListener('keydown', handleUrlKeydown);
            urlInput.removeEventListener('input', handleUrlInput);
            
            // Add enhanced paste event listener
            urlInput.addEventListener('paste', handleUrlPaste);
            
            // Add keyboard support for Enter key
            urlInput.addEventListener('keydown', handleUrlKeydown);
            
            // Add input validation
            urlInput.addEventListener('input', handleUrlInput);
        }

        /**
         * Handle paste events for URL input
         */
        function handleUrlPaste(event) {
            event.preventDefault();
            
            // Get clipboard data
            const clipboardData = event.clipboardData || window.clipboardData;
            let pastedText = clipboardData.getData('text/plain') || clipboardData.getData('text');
            
            if (pastedText) {
                // Clean up the pasted text
                pastedText = pastedText.trim();
                
                // Remove any extra whitespace or line breaks
                pastedText = pastedText.replace(/\s+/g, ' ').trim();
                
                // Set the cleaned text to input
                const urlInput = document.getElementById('urlInput');
                urlInput.value = pastedText;
                
                // Trigger input event for validation
                urlInput.dispatchEvent(new Event('input', { bubbles: true }));
                
                console.log('URL yapıştırıldı:', pastedText);
                showUrlStatus('success', 'URL yapıştırıldı ve temizlendi', 'check');
            }
        }

        /**
         * Handle keyboard events for URL input
         */
        function handleUrlKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                loadFromUrl();
            } else if (event.key === 'Escape') {
                closePopup();
            }
        }

        /**
         * Handle input validation for URL input
         */
        function handleUrlInput(event) {
            const urlInput = event.target;
            const url = urlInput.value.trim();
            
            // Clear previous status messages
            const urlStatus = document.getElementById('urlStatus');
            if (url.length === 0) {
                urlStatus.classList.add('hidden');
                return;
            }
            
            // Basic URL validation
            try {
                if (url.length > 10 && (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('ftp://'))) {
                    showUrlStatus('success', 'Geçerli URL formatı algılandı', 'check');
                } else if (url.length > 5) {
                    showUrlStatus('warning', 'URL protokolü eksik olabilir (http/https)', 'exclamation-triangle');
                }
            } catch (error) {
                showUrlStatus('error', 'Geçersiz URL formatı', 'exclamation-circle');
            }
        }

        /**
         * Close URL popup
         */
        function closePopup() {
            const popup = document.getElementById('popupOverlay');
            const urlLoading = document.getElementById('urlLoading');
            const urlStatus = document.getElementById('urlStatus');
            
            popup.classList.add('hidden');
            urlLoading.classList.add('hidden');
            urlStatus.classList.add('hidden');
            
            // Remove global paste listener when popup closes
            removeGlobalPasteListener();
        }

        // Global paste listener variable
        let globalPasteListener = null;

        /**
         * Setup global Ctrl+V listener when popup is open
         */
        function setupGlobalPasteListener() {
            // Remove existing listener if any
            removeGlobalPasteListener();
            
            globalPasteListener = function(event) {
                const popup = document.getElementById('popupOverlay');
                
                // Only handle if popup is visible and Ctrl+V is pressed
                if (!popup.classList.contains('hidden') && 
                    event.ctrlKey && event.key === 'v') {
                    
                    event.preventDefault();
                    
                    // Try to read from clipboard
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        navigator.clipboard.readText().then(text => {
                            if (text) {
                                pasteTextToUrlInput(text);
                            }
                        }).catch(err => {
                            console.log('Clipboard okuma hatası:', err);
                            showUrlStatus('warning', 'Panoya erişim izni gerekli. Ctrl+V yerine URL kutusuna sağ tık yapın.', 'exclamation-triangle');
                        });
                    } else {
                        // Fallback: Focus on input and let browser handle paste
                        const urlInput = document.getElementById('urlInput');
                        urlInput.focus();
                        showUrlStatus('info', 'URL kutusuna odaklanıldı. Tekrar Ctrl+V yapın.', 'info-circle');
                    }
                }
            };
            
            // Add global keydown listener
            document.addEventListener('keydown', globalPasteListener);
            console.log('Global Ctrl+V listener eklendi');
        }

        /**
         * Remove global paste listener
         */
        function removeGlobalPasteListener() {
            if (globalPasteListener) {
                document.removeEventListener('keydown', globalPasteListener);
                globalPasteListener = null;
                console.log('Global Ctrl+V listener kaldırıldı');
            }
        }

        /**
         * Paste text to URL input with processing
         */
        function pasteTextToUrlInput(text) {
            if (text) {
                // Clean up the pasted text
                const cleanedText = text.trim().replace(/\s+/g, ' ').trim();
                
                const urlInput = document.getElementById('urlInput');
                urlInput.value = cleanedText;
                urlInput.focus();
                
                // Trigger input event for validation
                urlInput.dispatchEvent(new Event('input', { bubbles: true }));
                
                console.log('Global Ctrl+V ile URL yapıştırıldı:', cleanedText);
                showUrlStatus('success', 'URL başarıyla yapıştırıldı', 'check');
            }
        }

        /**
         * Enhanced PDF document loading
         */
        async function loadPDFDocument(url) {
            const loadingTask = pdfjsLib.getDocument({
                url: url,
                cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                cMapPacked: true,
                verbosity: 0,
                useSystemFonts: true,
                enableXfa: false,
                disableFontFace: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                enableWebGL: false
            });

            loadingTask.onProgress = function(progress) {
                if (progress.total > 0) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    const progressBar = document.getElementById('urlProgressBar');
                    if (progressBar) {
                        progressBar.style.width = `${Math.min(90, 60 + (percent * 0.3))}%`;
                    }
                }
            };

            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;

            currentFileInfo = {
                name: url.split('/').pop() || 'URL PDF',
                url: url,
                pages: totalPages
            };

            await extractBookmarks();
            await renderAllPagesSmartly();
            showPDFContainer();
            addToRecentFiles(currentFileInfo.name, totalPages, url, 1);

            hideLoading();
            showToast(`PDF başarıyla yüklendi: ${totalPages} sayfa`, 'success');
            console.log('PDF başarıyla yüklendi:', totalPages, 'sayfa');
        }

        // DEVICE DETECTION AND ZOOM SETUP
        function isMobileDevice() {
            return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function setInitialZoom() {
            if (!pdfDoc) {
                if (isMobileDevice()) {
                    scale = 1.02;
                    document.getElementById('zoomSlider').value = 102;
                    document.getElementById('zoomValue').textContent = '102%';
                    showToast('Mobil cihaz tespit edildi - Zoom %102 olarak ayarlandı', 'info');
                } else {
                    scale = 2.5;
                    document.getElementById('zoomSlider').value = 250;
                    document.getElementById('zoomValue').textContent = '250%';
                    showToast('Masaüstü cihaz tespit edildi - Zoom %250 olarak ayarlandı', 'info');
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            loadRecentFiles();
            updatePageInfo();
            setupToolbarDragging();
            setInitialZoom();
            checkUrlParameter();
            showToast('BELGESELSEMO PDF Viewer Enhanced Edition hazır! Ultra gelişmiş seçim ve manipülasyon araçları aktif.', 'success');
        });

        // ENHANCED SMOOTH AUTO-SCROLL - TITREME SORUNU GİDERİLDİ
        function startAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
            }
            if (smoothScrollFrame) {
                cancelAnimationFrame(smoothScrollFrame);
            }

            const mainContent = document.getElementById('mainContent');
            let lastTime = performance.now();

            function smoothScroll(currentTime) {
                if (!isAutoScrolling) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                // Pürüzsüz kaydırma hesaplaması
                const scrollAmount = (scrollSpeed * deltaTime * 0.05);

                if (mainContent.scrollTop + mainContent.clientHeight >= mainContent.scrollHeight - 10) {
                    toggleAutoScroll();
                    showToast('Belge sonuna ulaşıldı', 'info');
                    return;
                }

                // Titreme olmadan pürüzsüz kaydırma
                mainContent.scrollBy({
                    top: scrollAmount,
                    behavior: 'auto' // smooth yerine auto kullanarak titreme giderildi
                });

                smoothScrollFrame = requestAnimationFrame(smoothScroll);
            }

            smoothScrollFrame = requestAnimationFrame(smoothScroll);
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            if (smoothScrollFrame) {
                cancelAnimationFrame(smoothScrollFrame);
                smoothScrollFrame = null;
            }
        }

        // ENHANCED SELECT ALL DRAWINGS - CTRL+A DESTEĞİ
        function selectAllDrawings() {
            selectedDrawings.clear();

            const pageNum = getCurrentPageNumber();
            if (!pageNum) {
                showToast('Aktif sayfa bulunamadı', 'warning');
                return;
            }

            // Mevcut sayfadaki tüm çizimleri seç
            if (allPageDrawings.has(pageNum)) {
                const pageDrawings = allPageDrawings.get(pageNum);
                pageDrawings.forEach(drawing => {
                    selectedDrawings.add(drawing.id || `${drawing.type}_${Date.now()}_${Math.random()}`);
                });
            }

            // Görünür overlay'leri de seç
            document.querySelectorAll('.pdf-page .selection-overlay, .pdf-page .measurement-line, .pdf-page .text-editor').forEach(element => {
                const elementPageNum = parseInt(element.closest('.pdf-page')?.getAttribute('data-page-num'));
                if (elementPageNum === pageNum) {
                    element.classList.add('multi-selected');
                    selectedDrawings.add(`overlay_${elementPageNum}_${element.style.left}_${element.style.top}`);
                }
            });

            updateSelectionCount();

            if (selectedDrawings.size > 0) {
                showToast(`${selectedDrawings.size} çizim seçildi`, 'success');

                // Görsel geri bildirim
                const selectAllBtn = document.getElementById('selectAllTool');
                if (selectAllBtn) {
                    selectAllBtn.style.background = 'var(--accent-color)';
                    selectAllBtn.style.animation = 'pulse 0.5s ease';
                    setTimeout(() => {
                        selectAllBtn.style.background = '';
                        selectAllBtn.style.animation = '';
                    }, 500);
                }
            } else {
                showToast('Bu sayfada seçilebilir çizim yok', 'warning');
            }
        }

        // ENHANCED DELETE SELECTED DRAWINGS - DELETE TUŞU DESTEĞİ
        function deleteSelectedDrawings() {
            if (selectedDrawings.size === 0) {
                showToast('Önce çizim seçin', 'warning');
                return;
            }

            const pageNum = getCurrentPageNumber();
            let deletedCount = 0;

            // Çizim verilerinden sil
            if (allPageDrawings.has(pageNum)) {
                const pageDrawings = allPageDrawings.get(pageNum);
                const originalCount = pageDrawings.length;

                // Seçili çizimleri filtrele
                const filteredDrawings = pageDrawings.filter(drawing => {
                    const drawingId = drawing.id || `${drawing.type}_${Date.now()}_${Math.random()}`;
                    return !selectedDrawings.has(drawingId);
                });

                allPageDrawings.set(pageNum, filteredDrawings);
                deletedCount += originalCount - filteredDrawings.length;
            }

            // Görsel overlay'leri sil
            document.querySelectorAll('.multi-selected').forEach(element => {
                element.remove();
                deletedCount++;
            });

            // Canvas'ı temizle ve kalan çizimleri yeniden çiz
            const canvas = drawingCanvases.get(pageNum);
            const ctx = drawingContexts.get(pageNum);
            if (canvas && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Kalan çizimleri yeniden çiz
                if (allPageDrawings.has(pageNum)) {
                    redrawPageDrawings(pageNum);
                }

                // Kalıcı çizimlere kaydet
                persistentDrawings.set(pageNum, canvas.toDataURL());
            }

            // Seçimleri temizle
            selectedDrawings.clear();
            updateSelectionCount();

            if (deletedCount > 0) {
                showToast(`${deletedCount} çizim silindi`, 'success');

                // Silme için görsel geri bildirim
                const deleteBtn = document.getElementById('deleteSelectedTool');
                if (deleteBtn) {
                    deleteBtn.style.background = '#dc3545';
                    deleteBtn.style.animation = 'pulse 0.5s ease';
                    setTimeout(() => {
                        deleteBtn.style.background = '';
                        deleteBtn.style.animation = '';
                    }, 500);
                }
            } else {
                showToast('Silinecek çizim bulunamadı', 'warning');
            }
        }

        // ENHANCED COPY SELECTED DRAWINGS - CTRL+C DESTEĞİ
        function copySelectedDrawings() {
            if (selectedDrawings.size === 0) {
                showToast('Kopyalanacak çizim seçin', 'warning');
                return;
            }

            const pageNum = getCurrentPageNumber();
            copiedDrawings = [];

            // Canvas seçiminden kopyala
            document.querySelectorAll('.multi-selected').forEach(overlay => {
                const canvas = drawingCanvases.get(pageNum);
                if (canvas) {
                    const rect = overlay.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();

                    const x = (rect.left - canvasRect.left) * (canvas.width / canvasRect.width);
                    const y = (rect.top - canvasRect.top) * (canvas.height / canvasRect.height);
                    const width = rect.width * (canvas.width / canvasRect.width);
                    const height = rect.height * (canvas.height / canvasRect.height);

                    // Kopyalama için geçici canvas oluştur
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d');

                    // PDF içeriğini kopyala
                    const pdfCanvas = overlay.closest('.pdf-page').querySelector('canvas');
                    if (pdfCanvas) {
                        tempCtx.drawImage(pdfCanvas, x, y, width, height, 0, 0, width, height);
                    }

                    // Çizim içeriğini kopyala
                    tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

                    copiedDrawings.push({
                        imageData: tempCanvas.toDataURL(),
                        width: width,
                        height: height,
                        originalX: x,
                        originalY: y
                    });
                }
            });

            // Çizim verilerini de kopyala
            if (allPageDrawings.has(pageNum)) {
                const pageDrawings = allPageDrawings.get(pageNum);
                pageDrawings.forEach(drawing => {
                    const drawingId = drawing.id || `${drawing.type}_${Date.now()}_${Math.random()}`;
                    if (selectedDrawings.has(drawingId)) {
                        copiedDrawings.push({
                            type: 'drawing',
                            data: JSON.parse(JSON.stringify(drawing))
                        });
                    }
                });
            }

            // Gelişmiş clipboard sistemine kaydet
            clipboardData = {
                drawings: JSON.parse(JSON.stringify(copiedDrawings)),
                timestamp: Date.now(),
                sourcePageNum: pageNum
            };

            showToast(`${copiedDrawings.length} çizim panoya kopyalandı`, 'success');

            // Görsel geri bildirim
            const copyBtn = document.getElementById('copyTool') || document.querySelector('[onclick*="copySelectedDrawings"]');
            if (copyBtn) {
                copyBtn.style.background = 'var(--accent-color)';
                copyBtn.style.animation = 'pulse 0.5s ease';
                setTimeout(() => {
                    copyBtn.style.background = '';
                    copyBtn.style.animation = '';
                }, 500);
            }

            showClipboardNotification();
        }

        // ENHANCED PASTE DRAWINGS - CTRL+V DESTEĞİ
        function pasteDrawings() {
            if (!clipboardData || !clipboardData.drawings || clipboardData.drawings.length === 0) {
                showToast('Yapıştırılacak çizim yok - Önce kopyala', 'warning');
                return;
            }

            const pageNum = getCurrentPageNumber();
            const canvas = drawingCanvases.get(pageNum);
            const ctx = drawingContexts.get(pageNum);

            if (!canvas || !ctx) {
                showToast('Çizim canvas\'ı bulunamadı', 'error');
                return;
            }

            saveDrawingState(pageNum);

            let pastedCount = 0;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            clipboardData.drawings.forEach((item, index) => {
                if (item.type === 'drawing') {
                    // Çizim verisini yapıştır
                    const newDrawing = JSON.parse(JSON.stringify(item.data));
                    newDrawing.id = Date.now() + '_' + Math.random();

                    // Pozisyonu kaydır
                    if (newDrawing.points && newDrawing.points.length > 0) {
                        const offsetX = index * 20;
                        const offsetY = index * 20;
                        newDrawing.points = newDrawing.points.map(point => ({
                            x: point.x + offsetX,
                            y: point.y + offsetY
                        }));
                    }

                    if (!allPageDrawings.has(pageNum)) {
                        allPageDrawings.set(pageNum, []);
                    }
                    allPageDrawings.get(pageNum).push(newDrawing);
                    pastedCount++;

                } else if (item.imageData) {
                    // Görüntü verisini yapıştır
                    const img = new Image();
                    img.onload = () => {
                        const offsetX = centerX + (index * 20) - (item.width / 2);
                        const offsetY = centerY + (index * 20) - (item.height / 2);
                        ctx.drawImage(img, offsetX, offsetY, item.width, item.height);

                        // Kalıcı çizimleri güncelle
                        persistentDrawings.set(pageNum, canvas.toDataURL());
                    };
                    img.src = item.imageData;
                    pastedCount++;
                }
            });

            // Sayfayı yeniden çiz
            redrawPageDrawings(pageNum);

            showToast(`${pastedCount} çizim yapıştırıldı`, 'success');

            // Görsel geri bildirim
            const pasteBtn = document.getElementById('pasteTool') || document.querySelector('[onclick*="pasteDrawings"]');
            if (pasteBtn) {
                pasteBtn.style.background = 'var(--accent-color)';
                pasteBtn.style.animation = 'pulse 0.5s ease';
                setTimeout(() => {
                    pasteBtn.style.background = '';
                    pasteBtn.style.animation = '';
                }, 500);
            }
        }

        // FIXED MEASUREMENT TOOL - ARTIK TAM ÇALIŞIYOR
        function selectMeasureTool() {
            selectTool('measure');
            measurementPoints = [];
            showToast('Ölçüm aracı aktif - İlk noktayı tıklayın', 'info');
        }

        function startMeasurement(pageDiv, point, pageNum) {
            if (measurementPoints.length === 0) {
                measurementPoints = [point];
                showToast('İkinci noktayı seçin', 'info');

                // İlk nokta göstergesi ekle
                const firstPoint = document.createElement('div');
                firstPoint.className = 'measurement-point';
                firstPoint.style.position = 'absolute';
                firstPoint.style.left = (point.x - 5) + 'px';
                firstPoint.style.top = (point.y - 5) + 'px';
                firstPoint.style.width = '10px';
                firstPoint.style.height = '10px';
                firstPoint.style.background = 'var(--accent-color)';
                firstPoint.style.borderRadius = '50%';
                firstPoint.style.zIndex = '20';
                firstPoint.style.border = '2px solid white';
                firstPoint.dataset.measurementId = 'temp';
                pageDiv.appendChild(firstPoint);

            } else if (measurementPoints.length === 1) {
                measurementPoints.push(point);
                finalizeMeasurement(pageDiv, pageNum);
            }
        }

        function finalizeMeasurement(pageDiv, pageNum) {
            if (measurementPoints.length !== 2) return;

            const [point1, point2] = measurementPoints;
            const distance = Math.sqrt(
                Math.pow(point2.x - point1.x, 2) +
                Math.pow(point2.y - point1.y, 2)
            );

            // Pikselleri yaklaşık ölçülere çevir
            const distanceInMM = (distance / scale / 96 * 25.4);
            const distanceInCM = distanceInMM / 10;
            const distanceInInch = distanceInMM / 25.4;

            const measurementId = pageNum + '_' + Date.now();

            // Geçici noktayı kaldır
            pageDiv.querySelectorAll('[data-measurement-id="temp"]').forEach(el => el.remove());

            // Ölçüm çizgisi oluştur
            const line = document.createElement('div');
            line.className = 'measurement-line';
            line.dataset.measurementId = measurementId;

            const angle = Math.atan2(point2.y - point1.y, point2.x - point1.x) * 180 / Math.PI;
            const length = Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));

            line.style.position = 'absolute';
            line.style.left = point1.x + 'px';
            line.style.top = point1.y + 'px';
            line.style.width = length + 'px';
            line.style.height = '3px';
            line.style.background = 'var(--accent-color)';
            line.style.transformOrigin = '0 center';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '12';
            line.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

            // Ölçüm etiketleri oluştur
            const label = document.createElement('div');
            label.className = 'measurement-label';
            label.dataset.measurementId = measurementId;
            label.innerHTML = `
                <div style="background: var(--accent-color); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
                    ${distanceInCM.toFixed(2)} cm<br>
                    ${distanceInMM.toFixed(1)} mm<br>
                    ${distanceInInch.toFixed(2)} inch
                </div>
            `;
            label.style.position = 'absolute';
            label.style.left = ((point1.x + point2.x) / 2) + 'px';
            label.style.top = ((point1.y + point2.y) / 2 - 30) + 'px';
            label.style.zIndex = '13';
            label.style.transform = 'translate(-50%, -50%)';
            label.style.pointerEvents = 'none';

            // Nokta işaretçileri ekle
            const startPoint = document.createElement('div');
            startPoint.className = 'measurement-point';
            startPoint.dataset.measurementId = measurementId;
            startPoint.style.position = 'absolute';
            startPoint.style.left = (point1.x - 6) + 'px';
            startPoint.style.top = (point1.y - 6) + 'px';
            startPoint.style.width = '12px';
            startPoint.style.height = '12px';
            startPoint.style.background = 'var(--accent-color)';
            startPoint.style.borderRadius = '50%';
            startPoint.style.zIndex = '14';
            startPoint.style.border = '2px solid white';
            startPoint.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

            const endPoint = startPoint.cloneNode(true);
            endPoint.style.left = (point2.x - 6) + 'px';
            endPoint.style.top = (point2.y - 6) + 'px';

            pageDiv.appendChild(line);
            pageDiv.appendChild(label);
            pageDiv.appendChild(startPoint);
            pageDiv.appendChild(endPoint);

            // Ölçüm verisini sakla
            activeMeasurements.set(measurementId, {
                points: measurementPoints,
                distance: distanceInCM,
                pageNum: pageNum,
                elements: [line, label, startPoint, endPoint]
            });

            showToast(`Ölçüm tamamlandı: ${distanceInCM.toFixed(2)} cm`, 'success');
            measurementPoints = [];
        }

        // YENİ ARAÇLAR: DOĞRU (↔) VE DİK ÜÇGEN
        function addNewTools() {
            // Araçlar zaten HTML yapısında mevcut
            // Sadece çizim fonksiyonlarında işlenmesi gerekiyor
        }

        // ENHANCED DRAW SHAPE FUNCTION WITH NEW TOOLS
        function drawShape(ctx, tool, start, end) {
            const devicePixelRatio = window.devicePixelRatio || 1;
            const outputScale = devicePixelRatio * scale;

            let thicknessMultiplier = 1;
            ctx.lineWidth = brushSize * outputScale * thicknessMultiplier;
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = currentOpacity / 100;

            ctx.beginPath();

            const width = end.x - start.x;
            const height = end.y - start.y;
            const centerX = start.x + width / 2;
            const centerY = start.y + height / 2;
            const radius = Math.min(Math.abs(width), Math.abs(height)) / 2;

            switch(tool) {
                case 'line':
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    break;

    case 'straightLine': // ↔ V-şeklinde uçlu çizgi
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();

        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        const arrowLength = 15 * outputScale;

        // Başlangıç ucu (sola bakan V)
        ctx.beginPath();
        ctx.moveTo(start.x + arrowLength * Math.cos(angle + Math.PI / 6),
                   start.y + arrowLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(start.x, start.y);
        ctx.lineTo(start.x + arrowLength * Math.cos(angle - Math.PI / 6),
                   start.y + arrowLength * Math.sin(angle - Math.PI / 6));
        ctx.stroke();

        // Bitiş ucu (sağa bakan V)
        ctx.beginPath();
        ctx.moveTo(end.x - arrowLength * Math.cos(angle + Math.PI / 6),
                   end.y - arrowLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(end.x, end.y);
        ctx.lineTo(end.x - arrowLength * Math.cos(angle - Math.PI / 6),
                   end.y - arrowLength * Math.sin(angle - Math.PI / 6));
        ctx.stroke();
        break;

                case 'dashedLine':
                    ctx.setLineDash([10, 5]);
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    break;

                case 'rectangle':
                    ctx.strokeRect(start.x, start.y, width, height);
                    break;

                case 'circle':
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    break;

                case 'ellipse':
                    const radiusX = Math.abs(width) / 2;
                    const radiusY = Math.abs(height) / 2;
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                    break;

                case 'arrow':
                    const headLength = 20 * outputScale;
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    const arrowAngle = Math.atan2(end.y - start.y, end.x - start.x);
                    ctx.moveTo(end.x, end.y);
                    ctx.lineTo(end.x - headLength * Math.cos(arrowAngle - Math.PI / 6), end.y - headLength * Math.sin(arrowAngle - Math.PI / 6));
                    ctx.moveTo(end.x, end.y);
                    ctx.lineTo(end.x - headLength * Math.cos(arrowAngle + Math.PI / 6), end.y - headLength * Math.sin(arrowAngle + Math.PI / 6));
                    ctx.stroke();
                    break;

                case 'triangle':
                    ctx.moveTo(centerX, start.y);
                    ctx.lineTo(start.x, end.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.closePath();
                    ctx.stroke();
                    break;

                case 'rightTriangle': // YENİ: Dik üçgen aracı
                    ctx.moveTo(start.x, end.y); // Sol alt (dik açı)
                    ctx.lineTo(end.x, end.y);   // Sağ alt
                    ctx.lineTo(start.x, start.y); // Sol üst
                    ctx.closePath();
                    ctx.stroke();

                    // Dik açı göstergesi ekle
                    const rightAngleSize = Math.min(Math.abs(width), Math.abs(height)) * 0.1;
                    ctx.beginPath();
                    ctx.moveTo(start.x, end.y - rightAngleSize);
                    ctx.lineTo(start.x + rightAngleSize, end.y - rightAngleSize);
                    ctx.lineTo(start.x + rightAngleSize, end.y);
                    ctx.stroke();
                    break;

                case 'pentagon':
                    drawPolygon(ctx, centerX, centerY, radius, 5);
                    break;

                case 'hexagon':
                    drawPolygon(ctx, centerX, centerY, radius, 6);
                    break;

                case 'heptagon':
                    drawPolygon(ctx, centerX, centerY, radius, 7);
                    break;

                case 'star':
                    drawStar(ctx, centerX, centerY, radius, 5);
                    break;

                case 'crescent':
                    drawCrescent(ctx, centerX, centerY, radius);
                    break;

                case 'trapezoid':
                    const topWidth = Math.abs(width) * 0.6;
                    ctx.moveTo(start.x + (Math.abs(width) - topWidth) / 2, start.y);
                    ctx.lineTo(start.x + (Math.abs(width) + topWidth) / 2, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.lineTo(start.x, end.y);
                    ctx.closePath();
                    ctx.stroke();
                    break;

                case 'parallelogram':
                    const offset = Math.abs(width) * 0.3;
                    ctx.moveTo(start.x + offset, start.y);
                    ctx.lineTo(end.x, start.y);
                    ctx.lineTo(end.x - offset, end.y);
                    ctx.lineTo(start.x, end.y);
                    ctx.closePath();
                    ctx.stroke();
                    break;

                case 'deltoid':
                    ctx.moveTo(centerX, start.y);
                    ctx.lineTo(end.x, centerY);
                    ctx.lineTo(centerX, end.y);
                    ctx.lineTo(start.x, centerY);
                    ctx.closePath();
                    ctx.stroke();
                    break;

                case 'cube':
                    drawCube(ctx, start.x, start.y, Math.abs(width), Math.abs(height));
                    break;

                case 'cone':
                    drawCone(ctx, centerX, start.y, end.y, Math.abs(width));
                    break;

                case 'cylinder':
                    drawCylinder(ctx, start.x, start.y, Math.abs(width), Math.abs(height));
                    break;

                case 'triangularPrism':
                    drawTriangularPrism(ctx, start.x, start.y, Math.abs(width), Math.abs(height));
                    break;

                case 'rectangularPrism':
                    drawRectangularPrism(ctx, start.x, start.y, Math.abs(width), Math.abs(height));
                    break;

                case 'numberline':
                    drawNumberLine(ctx, start, end);
                    break;
            }
        }

        // Enhanced Drawing and Selection Functions
        function clearAllSelections() {
            selectedDrawings = new Set();
            isSelecting = false;
            selectionStart = null;
            selectionEnd = null;
            isManipulating = false;
            manipulationHandles = [];
            rotationAngle = 0;
            hideSelectionControls();
            redrawAllPages();
        }

        function clearSelection() {
            clearAllSelections();
        }

        function hideSelectionControls() {
            const controls = document.getElementById('manipulationControls');
            if (controls) {
                controls.style.display = 'none';
            }
        }

        function copySelectionToClipboard() {
            if (selectedDrawings.size > 0) {
                clipboardData = {
                    drawings: JSON.parse(JSON.stringify(Array.from(selectedDrawings))),
                    timestamp: Date.now()
                };
                showClipboardNotification();
                showToast(`${selectedDrawings.size} çizim panoya kopyalandı`, 'success');
            }
        }

        function pasteFromClipboard(x, y) {
            if (clipboardData && clipboardData.drawings) {
                const newDrawings = clipboardData.drawings.map(drawing => {
                    const newDrawing = JSON.parse(JSON.stringify(drawing));
                    if (newDrawing.points && newDrawing.points.length > 0) {
                        const offsetX = x - newDrawing.points[0].x;
                        const offsetY = y - newDrawing.points[0].y;
                        newDrawing.points = newDrawing.points.map(point => ({
                            x: point.x + offsetX,
                            y: point.y + offsetY
                        }));
                    }
                    newDrawing.id = Date.now() + Math.random();
                    return newDrawing;
                });

                const pageNum = getCurrentPageNumber();
                if (!allPageDrawings.has(pageNum)) {
                    allPageDrawings.set(pageNum, []);
                }
                allPageDrawings.get(pageNum).push(...newDrawings);

                redrawCurrentPage();
                showToast('Çizimler yapıştırıldı', 'success');
            }
        }

        function showClipboardNotification() {
            const overlay = document.getElementById('clipboardOverlay');
            if (overlay) {
                overlay.style.display = 'flex';
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 2000);
            }
        }

        // Enhanced Keyboard Shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'c':
                        if (selectedDrawings.size > 0) {
                            e.preventDefault();
                            copySelectedDrawings();
                        }
                        break;
                    case 'v':
                        e.preventDefault();
                        if (clipboardData) {
                            const rect = document.querySelector('.pdf-page canvas')?.getBoundingClientRect();
                            if (rect) {
                                const centerX = rect.width / 2;
                                const centerY = rect.height / 2;
                                pasteDrawings();
                            }
                        }
                        break;
                    case 'a':
                        e.preventDefault();
                        selectAllDrawings();
                        break;
                }
            }

            if (e.key === 'Delete' && selectedDrawings.size > 0) {
                e.preventDefault();
                deleteSelectedDrawings();
            }
        });

        function getCurrentPageNumber() {
            return currentPage || 1;
        }

        function redrawCurrentPage() {
            renderPage(getCurrentPageNumber());
        }

        function redrawAllPages() {
            document.querySelectorAll('.pdf-page').forEach((pageElement, index) => {
                renderPage(index + 1);
            });
        }

        function redrawPageDrawings(pageNum) {
            if (!allPageDrawings.has(pageNum)) return;

            const canvas = drawingCanvases.get(pageNum);
            const ctx = drawingContexts.get(pageNum);
            if (!canvas || !ctx) return;

            const drawings = allPageDrawings.get(pageNum);
            drawings.forEach(drawing => {
                // Her çizimi türüne göre yeniden çiz
                ctx.globalAlpha = (drawing.opacity || 100) / 100;
                ctx.strokeStyle = drawing.color || currentColor;
                ctx.lineWidth = drawing.lineWidth || brushSize;

                if (drawing.points && drawing.points.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(drawing.points[0].x, drawing.points[0].y);
                    for (let i = 1; i < drawing.points.length; i++) {
                        ctx.lineTo(drawing.points[i].x, drawing.points[i].y);
                    }
                    ctx.stroke();
                }
            });

            persistentDrawings.set(pageNum, canvas.toDataURL());
        }

        function updateSelectionCount() {
            const countElement = document.getElementById('selectionCount');
            if (countElement) {
                if (selectedDrawings.size > 0) {
                    countElement.textContent = selectedDrawings.size;
                    countElement.style.display = 'block';
                } else {
                    countElement.style.display = 'none';
                }
            }
        }

        // [Orijinal HTML'deki tüm diğer fonksiyonlar buraya devam ediyor...]

        function initializeEventListeners() {
            document.addEventListener('keydown', handleKeyboardShortcuts);
            document.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', (e) => {
                if (isManipulating && !e.target.closest('.selection-overlay') && !e.target.closest('.manipulation-handle')) {
                    finishManipulation();
                }
            });
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleFileDrop);
            setupModalAutoClose();
            setupMobileRotationSupport();

            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    adjustToolbarPosition();
                    setInitialZoom();
                    if (pdfDoc) {
                        adjustPDFPagesToViewport();
                        goToPage(currentPage);
                    }
                }, 250);
            });

            document.getElementById('mainContent').addEventListener('scroll', debounce(() => {
                updateCurrentPageFromScroll();
                updateLastViewedPage();
            }, 150));

            document.addEventListener('click', (e) => {
                const bookmarksPanel = document.getElementById('bookmarksPanel');
                const bookmarkIcon = document.querySelector('[onclick*="toggleBookmarks"]');

                if (bookmarksPanel.classList.contains('show') &&
                    !bookmarksPanel.contains(e.target) &&
                    !bookmarkIcon.contains(e.target)) {
                    bookmarksPanel.classList.remove('show');
                }
            });

            document.addEventListener('click', (e) => {
                const drawingToolbar = document.getElementById('drawingToolbar');
                const drawingIcon = document.querySelector('[onclick*="toggleDrawingTools"]');

                if (drawingToolbar.classList.contains('show') &&
                    !drawingToolbar.contains(e.target) &&
                    !drawingIcon.contains(e.target) &&
                    !e.target.closest('.pdf-page') &&
                    !e.target.closest('.footer') &&
                    !isDraggingToolbar) {

                    if (!isDrawing && !isSelecting && !isManipulating) {
                        toggleDrawingTools();
                    }
                }
            });
        }

        // Helper Functions
        function drawPolygon(ctx, centerX, centerY, radius, sides) {
            const angle = (2 * Math.PI) / sides;
            ctx.moveTo(centerX + radius * Math.cos(0), centerY + radius * Math.sin(0));
            for (let i = 1; i <= sides; i++) {
                ctx.lineTo(centerX + radius * Math.cos(i * angle), centerY + radius * Math.sin(i * angle));
            }
            ctx.stroke();
        }

        function drawStar(ctx, centerX, centerY, radius, points) {
            const outerRadius = radius;
            const innerRadius = radius * 0.4;
            const angle = Math.PI / points;

            ctx.moveTo(centerX + outerRadius * Math.cos(0), centerY + outerRadius * Math.sin(0));
            for (let i = 0; i < 2 * points; i++) {
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                ctx.lineTo(centerX + r * Math.cos(i * angle), centerY + r * Math.sin(i * angle));
            }
            ctx.closePath();
            ctx.stroke();
        }

        function drawCrescent(ctx, centerX, centerY, radius) {
            ctx.save();
            const innerCenterX = centerX + radius * 0.4;
            const innerRadius = radius * 0.8;
            const d = innerCenterX - centerX;
            const x = (d * d - innerRadius * innerRadius + radius * radius) / (2 * d);
            const y = Math.sqrt(Math.max(0, radius * radius - x * x));
            const outerAngle = Math.atan2(y, x);
            const innerAngle = Math.atan2(y, x - d);

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, outerAngle, -outerAngle, false);
            ctx.arc(innerCenterX, centerY, innerRadius, -innerAngle, innerAngle, true);
            ctx.closePath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = 'rgba(255, 182, 193, 0.8)';
            ctx.fill();
            ctx.restore();
        }

        function drawCube(ctx, x, y, width, height) {
            const depth = Math.min(width, height) * 0.3;
            ctx.strokeRect(x, y, width, height);
            ctx.strokeRect(x + depth, y - depth, width, height);
            ctx.moveTo(x, y);
            ctx.lineTo(x + depth, y - depth);
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width + depth, y - depth);
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + depth, y + height - depth);
            ctx.moveTo(x + width, y + height);
            ctx.lineTo(x + width + depth, y + height - depth);
            ctx.stroke();
        }

        function drawCone(ctx, centerX, topY, bottomY, width) {
            ctx.moveTo(centerX, topY);
            ctx.lineTo(centerX - width / 2, bottomY);
            ctx.lineTo(centerX + width / 2, bottomY);
            ctx.closePath();
            ctx.ellipse(centerX, bottomY, width / 2, width / 8, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawCylinder(ctx, x, y, width, height) {
            const ellipseHeight = height * 0.1;
            ctx.ellipse(x + width / 2, y, width / 2, ellipseHeight, 0, 0, 2 * Math.PI);
            ctx.ellipse(x + width / 2, y + height, width / 2, ellipseHeight, 0, 0, 2 * Math.PI);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height);
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width, y + height);
            ctx.stroke();
        }

        function drawTriangularPrism(ctx, x, y, width, height) {
            const depth = width * 0.3;
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x, y + height);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.moveTo(x + width / 2 + depth, y - depth);
            ctx.lineTo(x + depth, y + height - depth);
            ctx.lineTo(x + width + depth, y + height - depth);
            ctx.closePath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width / 2 + depth, y - depth);
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + depth, y + height - depth);
            ctx.moveTo(x + width, y + height);
            ctx.lineTo(x + width + depth, y + height - depth);
            ctx.stroke();
        }

        function drawRectangularPrism(ctx, x, y, width, height) {
            const depth = Math.min(width, height) * 0.3;
            ctx.strokeRect(x, y, width, height);
            ctx.strokeRect(x + depth, y - depth, width, height);
            ctx.moveTo(x, y);
            ctx.lineTo(x + depth, y - depth);
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width + depth, y - depth);
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + depth, y + height - depth);
            ctx.moveTo(x + width, y + height);
            ctx.lineTo(x + width + depth, y + height - depth);
            ctx.stroke();
        }

        function drawNumberLine(ctx, start, end) {
            const length = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            const angle = Math.atan2(end.y - start.y, end.x - start.x);

            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();

            const tickCount = Math.max(5, Math.min(20, Math.floor(length / 30)));
            const tickSpacing = length / tickCount;

            ctx.font = `${Math.max(10, brushSize + 8)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            for (let i = 0; i <= tickCount; i++) {
                const tickPos = i * tickSpacing;
                const tickX = start.x + Math.cos(angle) * tickPos;
                const tickY = start.y + Math.sin(angle) * tickPos;

                const isMajor = i % 5 === 0;
                const tickHeight = isMajor ? 20 : 10;

                const perpAngle = angle + Math.PI / 2;
                ctx.moveTo(tickX - Math.cos(perpAngle) * tickHeight / 2,
                          tickY - Math.sin(perpAngle) * tickHeight / 2);
                ctx.lineTo(tickX + Math.cos(perpAngle) * tickHeight / 2,
                          tickY + Math.sin(perpAngle) * tickHeight / 2);
                ctx.stroke();

                if (isMajor) {
                    const labelX = tickX + Math.cos(perpAngle) * 25;
                    const labelY = tickY + Math.sin(perpAngle) * 25;
                    ctx.fillText(i.toString(), labelX, labelY);
                }
            }
        }

        // Placeholder for all other original functions...
        // [Include all the remaining functions from the original code]

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.style.top = '-100px';
                    toast.style.opacity = '0';
                    toast.style.visibility = 'hidden';
                }, 400);
            }, 4000);
        }

        // Enhanced Drag and Drop with Visual Feedback
        function handleDragOver(e) {
            e.preventDefault();
            const dropZone = document.getElementById('dropZone');
            if (e.dataTransfer.types.includes('Files')) {
                dropZone.classList.add('active');
            }
        }

        function handleDragLeave(e) {
            e.preventDefault();
            if (e.clientX === 0 || e.clientY === 0 ||
                e.clientX === window.innerWidth || e.clientY === window.innerHeight) {
                document.getElementById('dropZone').classList.remove('active');
            }
        }

        function handleFileDrop(e) {
            e.preventDefault();
            document.getElementById('dropZone').classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'application/pdf') {
                    clearPreviousPDF();
                    loadPDFFromFile(file);
                } else {
                    showToast('Lütfen sadece PDF dosyası sürükleyip bırakın!', 'warning');
                }
            }
        }

        // CLEAR PREVIOUS PDF FUNCTION
        function clearPreviousPDF() {
            if (isAutoScrolling) {
                toggleAutoScroll();
            }

            pdfDoc = null;
            currentPage = 1;
            totalPages = 0;
            currentFileInfo = null;

            pageCache.clear();
            drawingCanvases.clear();
            drawingContexts.clear();
            undoStack = {};
            redoStack = {};
            highlights.clear();
            selectedDrawings.clear();
            copiedDrawings = [];
            measurements.clear();
            textEditors.clear();
            numberLines.clear();
            activeSelections.clear();
            persistentDrawings.clear();

            searchResults = [];
            currentSearchIndex = -1;
            bookmarks = [];

            clearAllSelections();
            finishManipulation();

            document.getElementById('pdfContainer').innerHTML = '';
            document.getElementById('pdfContainer').classList.remove('show');

            if (visiblePageObserver) {
                visiblePageObserver.disconnect();
                visiblePageObserver = null;
            }

            hideAllModals();
            updatePageInfo();
            document.getElementById('welcomeScreen').style.display = 'flex';

            showToast('Önceki PDF temizlendi, yeni PDF yükleniyor...', 'info');
        }

        function adjustToolbarPosition() {
            const toolbar = document.getElementById('drawingToolbar');
            const rect = toolbar.getBoundingClientRect();

            if (rect.left < 0 || rect.top < 0 ||
                rect.right > window.innerWidth || rect.bottom > window.innerHeight) {
                toolbar.style.left = '2%';
                toolbar.style.top = window.innerWidth <= 768 ? '42px' : '50px';
                toolbar.style.transform = 'none';
            }
        }

        // ENHANCED Mobile Rotation Support
        function setupMobileRotationSupport() {
            const rotateLeftBtn = document.querySelector('[onclick*="rotatePDF(-90)"]');
            const rotateRightBtn = document.querySelector('[onclick*="rotatePDF(90)"]');

            if (rotateLeftBtn) {
                rotateLeftBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    rotatePDF(-90);
                }, { passive: false });
            }

            if (rotateRightBtn) {
                rotateRightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    rotatePDF(90);
                }, { passive: false });
            }

            document.querySelectorAll('.footer-icon, .icon, .drawing-tool, .color-picker').forEach(element => {
                element.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    element.style.transform = 'scale(0.95)';
                }, { passive: true });

                element.addEventListener('touchend', (e) => {
                    element.style.transform = '';
                }, { passive: true });
            });
        }

        function handleContextMenu(e) {
            e.preventDefault();

            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';

            let x = e.pageX;
            let y = e.pageY;

            const menuRect = contextMenu.getBoundingClientRect();
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';

            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 10);
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
        }

        function contextMenuAction(action) {
            hideContextMenu();

            switch(action) {
                case 'copy':
                    if (selectedDrawings.size > 0) {
                        copySelectedDrawings();
                    } else {
                        showToast('Kopyalanacak çizim seçin', 'warning');
                    }
                    break;
                case 'selectAll':
                    selectAllDrawings();
                    break;
                case 'zoomIn':
                    zoomIn();
                    break;
                case 'zoomOut':
                    zoomOut();
                    break;
                case 'rotateLeft':
                    rotatePDF(-90);
                    break;
                case 'rotateRight':
                    rotatePDF(90);
                    break;
                case 'fullscreen':
                    toggleFullscreen();
                    break;
                case 'printPage':
                    printCurrentPage();
                    break;
                case 'saveImage':
                    saveCurrentPageAsImage();
                    break;
            }
        }

        function printCurrentPage() {
            if (!pdfDoc) {
                showToast('Önce bir PDF yükleyin!', 'warning');
                return;
            }

            const currentPageElement = document.querySelector(`[data-page-num="${currentPage}"] canvas`);
            if (currentPageElement) {
                const printWindow = window.open('', '_blank');
                printWindow.document.write(`
                    <html>
                        <head><title>Sayfa ${currentPage} - Yazdır</title></head>
                        <body style="margin:0; display:flex; justify-content:center; align-items:center; min-height:100vh;">
                            <img src="${currentPageElement.toDataURL()}" style="max-width:100%; max-height:100%; object-fit:contain;" />
                        </body>
                    </html>
                `);
                printWindow.document.close();
                printWindow.print();
                showToast(`Sayfa ${currentPage} yazdırılıyor`, 'success');
            } else {
                showToast('Sayfa henüz yüklenmemiş', 'warning');
            }
        }

        function saveCurrentPageAsImage() {
            if (!pdfDoc) {
                showToast('Önce bir PDF yükleyin!', 'warning');
                return;
            }

            const currentPageElement = document.querySelector(`[data-page-num="${currentPage}"] canvas`);
            if (currentPageElement) {
                const link = document.createElement('a');
                link.download = `sayfa_${currentPage}_${Date.now()}.png`;
                link.href = currentPageElement.toDataURL('image/png', 1.0);
                link.click();
                showToast(`Sayfa ${currentPage} Ultra HD kalitede kaydedildi`, 'success');
            } else {
                showToast('Sayfa henüz yüklenmemiş', 'warning');
            }
        }

        // ENHANCED AUTO-CLOSE MODALS Setup
        function setupModalAutoClose() {
            const modals = [
                { id: 'themePopup', content: '.theme-popup-content' },
                { id: 'searchModal', content: '.modal-content' },
                { id: 'urlModal', content: '.modal-content' },
                { id: 'recentFilesModal', content: '.recent-files-content' },
                { id: 'infoPopup', content: '.info-content' },
                { id: 'hotkeyPopup', content: '.hotkey-content' }
            ];

            modals.forEach(({ id, content }) => {
                const modal = document.getElementById(id);
                if (modal) {
                    modal.addEventListener('click', function(e) {
                        const contentElement = this.querySelector(content);
                        if (contentElement && !contentElement.contains(e.target)) {
                            hideModalById(id);
                        }
                    });
                }
            });

            document.addEventListener('click', function(e) {
                if (e.target.closest('.drawing-toolbar') ||
                    e.target.closest('.auto-scroll-container') ||
                    e.target.closest('.zoom-container') ||
                    e.target.closest('.selection-overlay') ||
                    e.target.closest('.manipulation-handle') ||
                    isDraggingToolbar || isManipulating) {
                    return;
                }

                const openModals = document.querySelectorAll('.modal-overlay.show, .theme-popup.show, .recent-files-modal.show, .info-popup.show, .hotkey-popup.show');
                openModals.forEach(modal => {
                    if (!modal.querySelector('*').contains(e.target)) {
                        modal.classList.remove('show');
                    }
                });
            });
        }

        function hideModalById(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // URL Parameter Support
        function checkUrlParameter() {
            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrl = urlParams.get('pdf');

            if (pdfUrl) {
                showToast('URL parametresinden PDF yükleniyor...', 'info');
                setTimeout(() => {
                    loadFromUrlDirect(pdfUrl);
                }, 1000);
            }
        }

        async function loadFromUrlDirect(url) {
            if (!url) return;

            clearPreviousPDF();
            showLoading('URL analiz ediliyor...', 10);

            try {
                // Enhanced URL analysis and processing
                let finalUrl = await analyzePDFUrl(url);
                showLoading('PDF yükleniyor...', 30);

                // Try direct loading first
                if (!url.startsWith('data:') && !url.includes('localhost') && !url.includes('127.0.0.1')) {
                    try {
                        const testResponse = await fetch(finalUrl, { 
                            method: 'HEAD',
                            headers: {
                                'Accept': 'application/pdf,*/*'
                            }
                        });
                        if (!testResponse.ok) throw new Error('Direct access failed');
                        showLoading('Direkt bağlantı başarılı...', 50);
                    } catch (directError) {
                        console.log('Direct loading failed, trying proxies:', directError);
                        showLoading('Proxy sunucuları deneniyor...', 40);
                        finalUrl = await loadPDFWithProxies(finalUrl);
                    }
                }

                const loadingTask = pdfjsLib.getDocument({
                    url: finalUrl,
                    cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                    cMapPacked: true,
                    verbosity: 0,
                    useSystemFonts: true,
                    enableXfa: false,
                    disableFontFace: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                    enableWebGL: false
                });

                loadingTask.onProgress = function(progress) {
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateProgress(percent);
                    }
                };

                pdfDoc = await loadingTask.promise;
                totalPages = pdfDoc.numPages;

                currentFileInfo = {
                    name: url.split('/').pop() || 'URL PDF',
                    url: url,
                    pages: totalPages
                };

                await extractBookmarks();
                await renderAllPagesSmartly();
                showPDFContainer();
                addToRecentFiles(currentFileInfo.name, totalPages, url, 1);

                hideLoading();
                showToast(`URL'den PDF başarıyla yüklendi! (${totalPages} sayfa)`, 'success');

            } catch (error) {
                hideLoading();
                showToast('URL\'den PDF yüklenirken hata oluştu!', 'error');
                console.error('URL PDF loading error:', error);
            }
        }

        function updateLastViewedPage() {
            if (currentFileInfo && currentPage) {
                currentFileInfo.lastPage = currentPage;
            }
        }

        function handleKeyboardShortcuts(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // ENHANCED HOTKEY SUPPORT WITH POPUP CLOSING
            if (e.key === 'Escape') {
                e.preventDefault();
                hideAllModals();
                clearAllSelections();
                finishManipulation();
                return;
            }

            // Check if any popup is open and allow them to close themselves
            const openPopups = document.querySelectorAll('.modal-overlay.show, .theme-popup.show, .recent-files-modal.show, .info-popup.show, .hotkey-popup.show');
            if (openPopups.length > 0) {
                if ((e.key === 'i' || e.key === 'I') && document.getElementById('infoPopup').classList.contains('show')) {
                    e.preventDefault();
                    hideInfoPopup();
                    return;
                }
                if ((e.key === 'h' || e.key === 'H') && document.getElementById('hotkeyPopup').classList.contains('show')) {
                    e.preventDefault();
                    hideHotkeyPopup();
                    return;
                }
                return;
            }

            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'o':
                        e.preventDefault();
                        openFilePicker();
                        break;
                    case 'f':
                        e.preventDefault();
                        openSearchModal();
                        break;
                    case 'r':
                        e.preventDefault();
                        showRecentFiles();
                        break;
                    case 't':
                        e.preventDefault();
                        showThemePopup();
                        break;
                    case 'b':
                        e.preventDefault();
                        toggleBookmarks();
                        break;
                    case 'd':
                        e.preventDefault();
                        toggleDrawingTools();
                        break;
                    case 's':
                        e.preventDefault();
                        if (isDrawingMode) {
                            saveDrawing();
                        }
                        break;
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redoDrawing();
                        } else {
                            undoDrawing();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        redoDrawing();
                        break;
                    case 'a':
                        e.preventDefault();
                        if (isDrawingMode) {
                            selectAllDrawings();
                        }
                        break;
                    case 'c':
                        e.preventDefault();
                        if (isDrawingMode && selectedDrawings.size > 0) {
                            copySelectedDrawings();
                        }
                        break;
                    case 'v':
                        e.preventDefault();
                        if (isDrawingMode && copiedDrawings.length > 0) {
                            pasteDrawings();
                        }
                        break;
                }
            } else {
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        previousPage();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        nextPage();
                        break;
                    case 'Home':
                        e.preventDefault();
                        goToFirstPage();
                        break;
                    case 'End':
                        e.preventDefault();
                        goToLastPage();
                        break;
                    case 'F11':
                        e.preventDefault();
                        toggleFullscreen();
                        break;
                    case '+':
                    case '=':
                        if (!e.ctrlKey) {
                            e.preventDefault();
                            zoomIn();
                        }
                        break;
                    case '-':
                        if (!e.ctrlKey) {
                            e.preventDefault();
                            zoomOut();
                        }
                        break;
                    case ' ':
                        e.preventDefault();
                        if (e.shiftKey) {
                            previousPage();
                        } else {
                            nextPage();
                        }
                        break;
                    case 'r':
                    case 'R':
                        e.preventDefault();
                        rotatePDF(90);
                        break;
                    case 'l':
                    case 'L':
                        e.preventDefault();
                        if (isDrawingMode) {
                            selectTool('lasso');
                        } else {
                            rotatePDF(-90);
                        }
                        break;
                    case 'b':
                    case 'B':
                        e.preventDefault();
                        toggleBookmarks();
                        break;
                    case 'f':
                    case 'F':
                        e.preventDefault();
                        toggleFullscreen();
                        break;
                    case 'i':
                    case 'I':
                        e.preventDefault();
                        showInfoPopup();
                        break;
                    case 'h':
                    case 'H':
                        e.preventDefault();
                        if (isDrawingMode) {
                            selectTool('highlight');
                        } else {
                            showHotkeyPopup();
                        }
                        break;
                    case 'd':
                    case 'D':
                        e.preventDefault();
                        toggleDrawingTools();
                        break;
                    case 'p':
                    case 'P':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('pen');
                        break;
                    case 'e':
                    case 'E':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('eraser');
                        break;
                    case 's':
                    case 'S':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('rectSelect');
                        break;
                    case 'g':
                    case 'G':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('hand');
                        break;
                    case 't':
                    case 'T':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('text');
                        break;
                    case 'c':
                    case 'C':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('screenshot');
                        break;
                    case 'm':
                    case 'M':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('measure');
                        break;
                    case 'n':
                    case 'N':
                        e.preventDefault();
                        if (isDrawingMode) selectTool('numberline');
                        break;
                    case 'o':
                    case 'O':
                        e.preventDefault();
                        showRecentFiles();
                        break;
                    case 'Delete':
                        e.preventDefault();
                        if (isDrawingMode && selectedDrawings.size > 0) {
                            deleteSelectedDrawings();
                        }
                        break;
                }
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // File Operations
        function openFilePicker() {
            document.getElementById('fileInput').click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                clearPreviousPDF();
                loadPDFFromFile(file);
            } else {
                showToast('Lütfen geçerli bir PDF dosyası seçin!', 'warning');
            }
        }

        async function loadPDFFromFile(file) {
            showLoading('PDF yükleniyor...', 0);

            try {
                const arrayBuffer = await file.arrayBuffer();
                const loadingTask = pdfjsLib.getDocument({
                    data: arrayBuffer,
                    cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                    cMapPacked: true,
                    verbosity: 0,
                    useSystemFonts: true,
                    disableFontFace: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                    enableXfa: false,
                    enableWebGL: false
                });

                loadingTask.onProgress = function(progress) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    updateProgress(percent);
                };

                pdfDoc = await loadingTask.promise;
                totalPages = pdfDoc.numPages;

                currentFileInfo = {
                    name: file.name,
                    path: file.name,
                    pages: totalPages
                };

                await extractBookmarks();
                await renderAllPagesSmartly();
                showPDFContainer();
                addToRecentFiles(file.name, totalPages, null, 1);

                hideLoading();
                showToast(`${file.name} başarıyla yüklendi! (${totalPages} sayfa)`, 'success');

            } catch (error) {
                hideLoading();
                showToast('PDF yüklenirken hata oluştu!', 'error');
                console.error('PDF loading error:', error);
            }
        }

        /**
         * Enhanced PDF loading from URL with improved error handling
         */
        async function loadFromUrl() {
            const urlInput = document.getElementById('urlInput');
            const inputUrl = urlInput.value.trim();
            
            if (!inputUrl) {
                showUrlStatus('error', 'Lütfen geçerli bir URL girin', 'exclamation-circle');
                return;
            }
            
            console.log('Popup\'tan PDF yükleme başlatılıyor:', inputUrl);
            
            const loadingElement = document.getElementById('urlLoading');
            const loadingText = document.getElementById('urlLoadingText');
            const progressBar = document.getElementById('urlProgressBar');
            
            try {
                // Show loading state
                loadingElement.classList.remove('hidden');
                loadingText.textContent = 'URL analiz ediliyor...';
                progressBar.style.width = '20%';
                
                // Clear previous PDF first
                clearPreviousPDF();
                showLoading('URL analiz ediliyor...', 10);
                
                // Analyze and process the URL - same as URL parameter method
                const processedUrl = await analyzePDFUrl(inputUrl);
                
                loadingText.textContent = 'PDF yükleniyor...';
                progressBar.style.width = '50%';
                showLoading('PDF yükleniyor...', 30);
                
                // Enhanced URL analysis and processing - same as loadFromUrlDirect
                let finalUrl = processedUrl;

                // Try direct loading first
                if (!inputUrl.startsWith('data:') && !inputUrl.includes('localhost') && !inputUrl.includes('127.0.0.1')) {
                    try {
                        const testResponse = await fetch(finalUrl, { 
                            method: 'HEAD',
                            headers: {
                                'Accept': 'application/pdf,*/*'
                            }
                        });
                        if (!testResponse.ok) throw new Error('Direct access failed');
                        showLoading('Direkt bağlantı başarılı...', 50);
                    } catch (directError) {
                        console.log('Direct loading failed, trying proxies:', directError);
                        showLoading('Proxy sunucuları deneniyor...', 40);
                        finalUrl = await loadPDFWithProxiesFromPopup(finalUrl, loadingText, progressBar);
                    }
                }

                // Load the PDF document
                const loadingTask = pdfjsLib.getDocument({
                    url: finalUrl,
                    cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                    cMapPacked: true,
                    verbosity: 0,
                    useSystemFonts: true,
                    enableXfa: false,
                    disableFontFace: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                    enableWebGL: false
                });

                loadingTask.onProgress = function(progress) {
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateProgress(Math.min(90, 60 + (percent * 0.3)));
                        if (progressBar) {
                            progressBar.style.width = `${Math.min(90, 60 + (percent * 0.3))}%`;
                        }
                    }
                };

                pdfDoc = await loadingTask.promise;
                totalPages = pdfDoc.numPages;

                currentFileInfo = {
                    name: inputUrl.split('/').pop() || 'URL PDF',
                    url: inputUrl,
                    pages: totalPages
                };

                await extractBookmarks();
                await renderAllPagesSmartly();
                showPDFContainer();
                addToRecentFiles(currentFileInfo.name, totalPages, inputUrl, 1);

                hideLoading();
                showToast(`PDF başarıyla yüklendi: ${totalPages} sayfa`, 'success');
                console.log('PDF başarıyla yüklendi:', totalPages, 'sayfa');
                
                progressBar.style.width = '100%';
                loadingText.textContent = 'PDF başarıyla yüklendi!';
                
                // Close popup after successful load
                setTimeout(() => {
                    closePopup();
                }, 1000);
                
            } catch (error) {
                console.error('PDF yükleme hatası:', error);
                showUrlStatus('error', 'PDF yüklenemedi: ' + error.message, 'exclamation-circle');
                loadingText.textContent = 'Hata: PDF yüklenemedi';
                progressBar.style.width = '0%';
                hideLoading();
                showToast('PDF yükleme hatası: ' + error.message, 'error');
            }
        }

        /**
         * Load PDF with proxies specifically for popup (with progress updates)
         */
        async function loadPDFWithProxiesFromPopup(url, loadingText, progressBar) {
            console.log('Popup için proxy yükleme başlatılıyor:', url);
            
            // Try with each proxy
            for (let i = 0; i < corsProxies.length; i++) {
                try {
                    const proxyUrl = corsProxies[i] + encodeURIComponent(url);
                    
                    loadingText.textContent = `Proxy ${i + 1}/${corsProxies.length} deneniyor...`;
                    progressBar.style.width = `${50 + (i * 40 / corsProxies.length)}%`;
                    showLoading(`Proxy ${i + 1} deneniyor...`, 40 + (i * 30 / corsProxies.length));
                    
                    console.log(`Proxy ${i + 1} deneniyor:`, corsProxies[i]);
                    showUrlStatus('warning', `Proxy ${i + 1}: ${corsProxies[i].split('/')[2]}`, 'server');
                    
                    // Test proxy with HEAD request
                    const proxyTestResponse = await fetch(proxyUrl, { 
                        method: 'HEAD',
                        headers: {
                            'Accept': 'application/pdf,application/octet-stream,*/*'
                        }
                    });
                    
                    if (proxyTestResponse.ok) {
                        console.log(`Proxy ${i + 1} test başarılı`);
                        showUrlStatus('success', `Proxy ${i + 1} ile başarılı!`, 'check-circle');
                        return proxyUrl;
                    }
                    
                } catch (proxyError) {
                    console.log(`Proxy ${i + 1} başarısız:`, proxyError);
                    showUrlStatus('warning', `Proxy ${i + 1} başarısız, sonraki deneniyor...`, 'exclamation-triangle');
                    continue;
                }
            }
            
            // If all proxies fail, return original URL
            showUrlStatus('warning', 'Tüm proxy\'ler başarısız, orijinal URL deneniyor...', 'exclamation-triangle');
            return url;
        }

        // ENHANCED MOBILE-OPTIMIZED PDF Rendering
        async function renderPage(pageNum, forceRender = false) {
            if (!pdfDoc) return null;

            if (!forceRender && pageCache.has(pageNum)) {
                return pageCache.get(pageNum);
            }

            try {
                const page = await pdfDoc.getPage(pageNum);
                let viewport = page.getViewport({ scale: scale, rotation: rotation });

                // Mobile detection and optimization
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isAndroid = /Android/i.test(navigator.userAgent);

                // Mobile-specific scaling adjustments for full width display
                if (isMobile) {
                    const containerWidth = document.getElementById('pdfContainer').clientWidth || window.innerWidth;
                    const scaleToFit = (containerWidth - 20) / viewport.width;
                    if (scale === 1.0 || scale < scaleToFit) {
                        scale = scaleToFit;
                        viewport = page.getViewport({ scale: scale, rotation: rotation });
                    }
                }

                const canvas = document.createElement('canvas');

                // Mobile-optimized canvas context settings
                const contextSettings = {
                    alpha: false,
                    desynchronized: !isMobile,
                    powerPreference: isMobile ? 'low-power' : 'high-performance',
                    willReadFrequently: isMobile,
                    antialias: !isMobile
                };

                const context = canvas.getContext('2d', contextSettings);

                // Canvas size optimization for mobile
                let canvasWidth = viewport.width;
                let canvasHeight = viewport.height;

                if (isMobile) {
                    // Limit canvas size on mobile to prevent memory issues
                    const maxSize = isAndroid ? 2048 : 4096;
                    if (canvasWidth > maxSize || canvasHeight > maxSize) {
                        const scaleDown = Math.min(maxSize / canvasWidth, maxSize / canvasHeight);
                        canvasWidth *= scaleDown;
                        canvasHeight *= scaleDown;
                        viewport = page.getViewport({ scale: scale * scaleDown, rotation: rotation });
                    }
                } else {
                    // Desktop high-quality rendering
                    const devicePixelRatio = Math.min(window.devicePixelRatio || 1, 3);
                    canvasWidth *= devicePixelRatio;
                    canvasHeight *= devicePixelRatio;
                    context.scale(devicePixelRatio, devicePixelRatio);
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Force full width on mobile
                if (isMobile) {
                    canvas.style.width = '100%';
                    canvas.style.maxWidth = '100%';
                    canvas.style.height = 'auto';
                    canvas.style.display = 'block';
                } else {
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                }

                // Mobile-specific rendering optimizations
                if (!isMobile) {
                    context.imageSmoothingEnabled = true;
                    context.imageSmoothingQuality = 'high';
                } else {
                    context.imageSmoothingEnabled = false; // Better performance on mobile
                }

                const renderContext = {
                    canvasContext: context,
                    viewport: viewport,
                    intent: 'display',
                    enableWebGL: false, // Disabled for mobile compatibility
                    renderInteractiveForms: false,
                    annotationMode: 0,
                    optionalContentConfigPromise: null,
                    background: 'white'
                };

                await page.render(renderContext).promise;

                pageCache.set(pageNum, canvas);
                return canvas;

            } catch (error) {
                console.error(`Error rendering page ${pageNum}:`, error);
                return null;
            }
        }

        // Smart PDF rendering
        async function renderAllPagesSmartly() {
            const container = document.getElementById('pdfContainer');
            container.innerHTML = '';

            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.setAttribute('data-page-num', pageNum);

                const placeholder = document.createElement('div');
                placeholder.className = 'loading-placeholder';
                placeholder.innerHTML = `
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">
                        <i class="fas fa-file-pdf" style="color: #e74c3c; margin-right: 8px;"></i>
                        Sayfa ${pageNum}
                    </div>
                    <div style="font-size: 14px; margin-bottom: 15px; opacity: 0.8;">Ultra HD kalitede yüklemek için tıklayın</div>
                    <button class="retry-btn" onclick="loadPageNow(${pageNum})">
                        <i class="fas fa-download" style="margin-right: 6px;"></i>
                        Yükle
                    </button>
                `;
                pageDiv.appendChild(placeholder);

                container.appendChild(pageDiv);

                updateProgress(Math.round((pageNum / totalPages) * 50));
            }

            setupPageObserver();
            await renderInitialPages();

            updatePageInfo();
            adjustPDFPagesToViewport();
        }

        async function renderInitialPages() {
            const initialPagesToRender = Math.min(3, totalPages);

            for (let pageNum = 1; pageNum <= initialPagesToRender; pageNum++) {
                await loadPageNow(pageNum);
            }
        }

        async function loadPageNow(pageNum) {
            const pageDiv = document.querySelector(`[data-page-num="${pageNum}"]`);
            if (!pageDiv) return;

            if (pageDiv.querySelector('canvas')) {
                return;
            }

            const placeholder = pageDiv.querySelector('.loading-placeholder');
            if (placeholder) {
                placeholder.innerHTML = `
                    <div style="font-size: 16px; color: var(--accent-color);">
                        <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
                        Sayfa ${pageNum} Ultra HD kalitede yükleniyor...
                    </div>
                `;
            }

            try {
                const canvas = await renderPage(pageNum);
                if (canvas && pageDiv.parentNode) {
                    pageDiv.innerHTML = '';
                    pageDiv.appendChild(canvas);

                    if (isDrawingMode) {
                        createDrawingCanvas(pageDiv, pageNum);
                    }

                    // RESTORE PERSISTENT DRAWINGS
                    if (persistentDrawings.has(pageNum)) {
                        const drawingCanvas = drawingCanvases.get(pageNum);
                        const ctx = drawingContexts.get(pageNum);
                        if (drawingCanvas && ctx) {
                            const img = new Image();
                            img.onload = () => {
                                ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                                ctx.drawImage(img, 0, 0);
                            };
                            img.src = persistentDrawings.get(pageNum);
                        }
                    }

                    if (isGridEnabled) {
                        const gridOverlay = document.createElement('div');
                        gridOverlay.className = 'grid-overlay show';
                        pageDiv.appendChild(gridOverlay);
                    }

                    if (highlights.has(pageNum)) {
                        highlights.get(pageNum).forEach(highlight => {
                            addHighlightOverlay(pageDiv, highlight);
                        });
                    }

                    adjustSinglePageToViewport(pageDiv);

                    canvas.style.opacity = '0';
                    canvas.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        canvas.style.transition = 'all 0.3s ease';
                        canvas.style.opacity = '1';
                        canvas.style.transform = 'scale(1)';
                    }, 50);
                }
            } catch (error) {
                console.error(`Failed to load page ${pageNum}:`, error);
                if (placeholder) {
                    placeholder.innerHTML = `
                        <div style="color: #e74c3c; font-size: 16px; margin-bottom: 10px;">
                            <i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                            Sayfa ${pageNum} yüklenemedi
                        </div>
                        <button class="retry-btn" onclick="loadPageNow(${pageNum})">
                            <i class="fas fa-redo" style="margin-right: 6px;"></i>
                            Tekrar Dene
                        </button>
                    `;
                }
            }
        }

        function setupPageObserver() {
            if (visiblePageObserver) {
                visiblePageObserver.disconnect();
            }

            visiblePageObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const pageNum = parseInt(entry.target.getAttribute('data-page-num'));

                        loadPageNow(pageNum);

                        const preloadRange = 2;
                        for (let i = Math.max(1, pageNum - preloadRange);
                             i <= Math.min(totalPages, pageNum + preloadRange); i++) {
                            if (i !== pageNum) {
                                setTimeout(() => loadPageNow(i), (Math.abs(i - pageNum) * 200));
                            }
                        }
                    }
                });
            }, {
                threshold: 0.1,
                rootMargin: '300px'
            });

            document.querySelectorAll('.pdf-page').forEach(page => {
                visiblePageObserver.observe(page);
            });
        }

        function adjustPDFPagesToViewport() {
            document.querySelectorAll('.pdf-page').forEach(pageDiv => {
                adjustSinglePageToViewport(pageDiv);
            });
        }

        function adjustSinglePageToViewport(pageDiv) {
            const canvas = pageDiv.querySelector('canvas');
            if (!canvas) return;

            // Mobile detection
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // Force full width on mobile
                const containerWidth = window.innerWidth - 10;
                canvas.style.width = '100%';
                canvas.style.maxWidth = '100vw';
                canvas.style.height = 'auto';
                canvas.style.display = 'block';

                // Ensure page container is also full width
                pageDiv.style.width = '100%';
                pageDiv.style.maxWidth = '100vw';
                pageDiv.style.margin = '5px auto';
            } else {
                // Desktop behavior
                const containerWidth = document.getElementById('mainContent').clientWidth - 20;
                canvas.style.width = '100%';
                canvas.style.maxWidth = containerWidth + 'px';
                canvas.style.height = 'auto';
            }

            const drawingCanvas = pageDiv.querySelector('.drawing-canvas');
            if (drawingCanvas) {
                drawingCanvas.style.width = canvas.style.width;
                drawingCanvas.style.height = canvas.style.height;
            }
        }

        function updateCurrentPageFromScroll() {
            const mainContent = document.getElementById('mainContent');
            const pages = document.querySelectorAll('.pdf-page');
            const scrollTop = mainContent.scrollTop;
            const viewportHeight = mainContent.clientHeight;
            const centerY = scrollTop + viewportHeight / 2;

            let closestPage = 1;
            let closestDistance = Infinity;

            pages.forEach(page => {
                const pageTop = page.offsetTop;
                const pageHeight = page.offsetHeight;
                const pageCenter = pageTop + pageHeight / 2;
                const distance = Math.abs(centerY - pageCenter);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPage = parseInt(page.getAttribute('data-page-num'));
                }
            });

            if (closestPage !== currentPage) {
                currentPage = closestPage;
                updatePageInfo();
            }
        }

        // Enhanced Bookmark Extraction
        async function extractBookmarks() {
            if (!pdfDoc) return;

            try {
                const outline = await pdfDoc.getOutline();
                bookmarks = [];

                if (outline && outline.length > 0) {
                    await processOutlineItems(outline, 0);
                    displayBookmarks();
                    showToast(`${bookmarks.length} yer imi bulundu`, 'info');
                } else {
                    await extractBookmarksFromContent();
                    if (bookmarks.length > 0) {
                        displayBookmarks();
                        showToast(`${bookmarks.length} olası başlık bulundu`, 'info');
                    }
                }

            } catch (error) {
                console.error('Error extracting bookmarks:', error);
            }
        }

        async function processOutlineItems(items, level) {
            for (const item of items) {
                try {
                    if (item.dest) {
                        let pageNum = 1;

                        if (typeof item.dest === 'string') {
                            const dest = await pdfDoc.getDestination(item.dest);
                            if (dest && dest[0]) {
                                pageNum = await pdfDoc.getPageIndex(dest[0]) + 1;
                            }
                        } else if (Array.isArray(item.dest) && item.dest[0]) {
                            pageNum = await pdfDoc.getPageIndex(item.dest[0]) + 1;
                        }

                        bookmarks.push({
                            title: item.title || 'Başlıksız',
                            pageNum: pageNum,
                            level: level
                        });
                    }

                    if (item.items && item.items.length > 0) {
                        await processOutlineItems(item.items, level + 1);
                    }
                } catch (error) {
                    console.error('Error processing bookmark item:', error);
                }
            }
        }

        async function extractBookmarksFromContent() {
            const maxPagesToAnalyze = Math.min(15, totalPages);

            for (let pageNum = 1; pageNum <= maxPagesToAnalyze; pageNum++) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    const potentialHeadings = textContent.items
                        .filter(item => {
                            return item.str &&
                                   item.str.trim().length > 3 &&
                                   item.str.trim().length < 100 &&
                                   item.height > 12 &&
                                   !/^\d+$/.test(item.str.trim()) &&
                                   !/^[.,;!?]+$/.test(item.str.trim()) &&
                                   !/^(sayfa|page|\d+\/\d+)$/i.test(item.str.trim());
                        })
                        .map(item => ({
                            title: item.str.trim(),
                            pageNum: pageNum,
                            level: 0,
                            fontSize: item.height
                        }))
                        .slice(0, 5);

                    bookmarks.push(...potentialHeadings);
                } catch (error) {
                    console.error(`Error extracting content from page ${pageNum}:`, error);
                }
            }

            bookmarks = bookmarks
                .filter((bookmark, index, self) =>
                    index === self.findIndex(b => b.title === bookmark.title)
                )
                .sort((a, b) => a.pageNum - b.pageNum)
                .slice(0, 30);

            if (bookmarks.length > 0) {
                displayBookmarks();
            }
        }

        function displayBookmarks() {
            const bookmarksList = document.getElementById('bookmarksList');

            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = `
                    <div style="color: rgba(255,255,255,0.5); text-align: center; padding: 30px; font-size: 16px;">
                        <i class="fas fa-bookmark" style="font-size: 48px; margin-bottom: 15px; display: block; opacity: 0.3;"></i>
                        Yer imi bulunamadı
                        <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">
                            PDF'de yer imleri varsa otomatik olarak burada görünecek
                        </div>
                    </div>
                `;
                return;
            }

            bookmarksList.innerHTML = '';

            bookmarks.forEach((bookmark, index) => {
                const bookmarkItem = document.createElement('div');
                bookmarkItem.className = 'bookmark-item';
                bookmarkItem.style.paddingLeft = (bookmark.level * 20 + 15) + 'px';
                bookmarkItem.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 6px; font-size: 15px; line-height: 1.3;">
                        <i class="fas fa-bookmark" style="margin-right: 8px; color: var(--accent-color); font-size: 12px;"></i>
                        ${bookmark.title}
                    </div>
                    <div style="font-size: 13px; color: var(--accent-color); font-weight: 600;">
                        <i class="fas fa-file-alt" style="margin-right: 4px;"></i>
                        Sayfa ${bookmark.pageNum}
                    </div>
                `;

                bookmarkItem.onclick = () => {
                    goToPage(bookmark.pageNum);
                    if (window.innerWidth <= 768) {
                        toggleBookmarks();
                    }
                    showToast(`"${bookmark.title}" - Sayfa ${bookmark.pageNum}`, 'info');
                };

                bookmarksList.appendChild(bookmarkItem);
            });
        }

        // Theme Management
        function showThemePopup(event) {
            if (event) event.stopPropagation();
            document.getElementById('themePopup').classList.add('show');
            updateThemeSelection();
        }

        function hideThemePopup() {
            document.getElementById('themePopup').classList.remove('show');
        }

        function selectTheme(themeName) {
            currentTheme = themeName;
            document.body.className = `theme-${themeName}`;
            updateThemeSelection();

            localStorage.setItem('pdfViewerTheme', themeName);
            showToast(`Tema değiştirildi: ${getThemeName(themeName)}`, 'success');
        }

        function updateThemeSelection() {
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('active');
            });
            const activeOption = document.querySelector(`[data-theme="${currentTheme}"]`);
            if (activeOption) {
                activeOption.classList.add('active');
            }
        }

        function applyCustomTheme() {
            const headerColor = document.getElementById('headerColor').value;
            const accentColor = document.getElementById('accentColor').value;

            document.documentElement.style.setProperty('--header-bg-start', headerColor);
            document.documentElement.style.setProperty('--header-bg-end', headerColor);
            document.documentElement.style.setProperty('--footer-bg-start', headerColor);
            document.documentElement.style.setProperty('--footer-bg-end', headerColor);
            document.documentElement.style.setProperty('--accent-color', accentColor);

            showToast('Özel tema uygulandı!', 'success');
        }

        function getThemeName(theme) {
            const names = {
                'default': 'Varsayılan',
                'forest': 'Orman',
                'sunset': 'Gün Batımı',
                'ocean': 'Okyanus',
                'purple': 'Mor',
                'dark': 'Karanlık',
                'golden': 'Altın',
                'emerald': 'Zümrüt',
                'crimson': 'Kızıl',
                'royal': 'Kraliyet'
            };
            return names[theme] || theme;
        }

        // Info and Hotkey Popups
        function showInfoPopup(event) {
            if (event) event.stopPropagation();
            document.getElementById('infoPopup').classList.add('show');
        }

        function hideInfoPopup() {
            document.getElementById('infoPopup').classList.remove('show');
        }

        function showHotkeyPopup(event) {
            if (event) event.stopPropagation();
            document.getElementById('hotkeyPopup').classList.add('show');
        }

        function hideHotkeyPopup() {
            document.getElementById('hotkeyPopup').classList.remove('show');
        }

        // Navigation Functions
        function goToPage(pageNum) {
            if (pageNum < 1 || pageNum > totalPages) return;

            currentPage = pageNum;
            updatePageInfo();
            updateLastViewedPage();

            const pageElement = document.querySelector(`[data-page-num="${pageNum}"]`);
            if (pageElement) {
                pageElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                });

                loadPageNow(pageNum);

                setTimeout(() => {
                    if (pageNum > 1) loadPageNow(pageNum - 1);
                    if (pageNum < totalPages) loadPageNow(pageNum + 1);
                }, 500);
            }
        }

        function goToFirstPage() {
            goToPage(1);
        }

        function goToLastPage() {
            goToPage(totalPages);
        }

        function nextPage() {
            if (currentPage < totalPages) {
                goToPage(currentPage + 1);
            } else {
                showToast('Son sayfadasınız', 'info');
            }
        }

        function previousPage() {
            if (currentPage > 1) {
                goToPage(currentPage - 1);
            } else {
                showToast('İlk sayfadasınız', 'info');
            }
        }

        function handlePageInputChange() {
            const pageInput = document.getElementById('pageInput');
            const pageNum = parseInt(pageInput.value);
            if (pageNum && pageNum >= 1 && pageNum <= totalPages) {
                goToPage(pageNum);
            } else {
                pageInput.value = currentPage;
                showToast('Geçersiz sayfa numarası!', 'warning');
            }
        }

        function updatePageInfo() {
            document.getElementById('pageInput').value = currentPage;
            document.getElementById('pageInfo').textContent = `/ ${totalPages}`;
        }

        // Zoom Functions
        function toggleZoomControls() {
            const container = document.getElementById('zoomContainer');
            const autoScrollContainer = document.getElementById('autoScrollContainer');

            if (autoScrollContainer.classList.contains('show')) {
                autoScrollContainer.classList.remove('show');
                stopAutoScroll();
                document.getElementById('autoScrollIcon').innerHTML = '<i class="fas fa-play"></i>';
                document.getElementById('autoScrollIcon').classList.remove('active');
            }

            container.classList.toggle('show');

            if (container.classList.contains('show')) {
                updateZoomSlider();
                showToast('Zoom kontrolleri açıldı', 'info');
            } else {
                showToast('Zoom kontrolleri kapatıldı', 'info');
            }
        }

        function updateZoomSlider() {
            const slider = document.getElementById('zoomSlider');
            const value = document.getElementById('zoomValue');
            const percentage = Math.round(scale * 100);

            slider.value = percentage;
            value.textContent = percentage + '%';
        }

        function setZoom(value) {
            scale = parseFloat(value) / 100;
            rerenderVisiblePages();
            updateZoomSlider();
        }

        function zoomIn() {
            scale = Math.min(scale * 1.25, 5.0);
            rerenderVisiblePages();
            updateZoomSlider();
            showToast(`Zoom: ${Math.round(scale * 100)}%`, 'info');
        }

        function zoomOut() {
            scale = Math.max(scale / 1.25, 0.25);
            rerenderVisiblePages();
            updateZoomSlider();
            showToast(`Zoom: ${Math.round(scale * 100)}%`, 'info');
        }

        async function rerenderVisiblePages() {
            if (!pdfDoc) return;

            // Save persistent drawings before clearing
            drawingCanvases.forEach((canvas, pageNum) => {
                if (canvas) {
                    persistentDrawings.set(pageNum, canvas.toDataURL());
                }
            });

            pageCache.clear();

            const visiblePages = document.querySelectorAll('.pdf-page canvas');
            const rerenderPromises = [];

            visiblePages.forEach(canvas => {
                const pageDiv = canvas.closest('.pdf-page');
                const pageNum = parseInt(pageDiv.getAttribute('data-page-num'));
                rerenderPromises.push(loadPageNow(pageNum));
            });

            drawingCanvases.clear();
            drawingContexts.clear();

            await Promise.all(rerenderPromises);
            adjustPDFPagesToViewport();
        }

        // Auto Scroll Functions
        function toggleAutoScroll() {
            isAutoScrolling = !isAutoScrolling;
            const icon = document.getElementById('autoScrollIcon');
            const container = document.getElementById('autoScrollContainer');
            const zoomContainer = document.getElementById('zoomContainer');

            if (zoomContainer.classList.contains('show')) {
                zoomContainer.classList.remove('show');
            }

            if (isAutoScrolling) {
                icon.innerHTML = '<i class="fas fa-pause"></i>';
                icon.classList.add('active');
                icon.title = 'Otomatik Kaydırmayı Durdur';
                container.classList.add('show');

                startAutoScroll();
                showToast('Otomatik kaydırma başlatıldı', 'success');
            } else {
                icon.innerHTML = '<i class="fas fa-play"></i>';
                icon.classList.remove('active');
                icon.title = 'Otomatik Kaydırma';
                container.classList.remove('show');
                stopAutoScroll();
                showToast('Otomatik kaydırma durduruldu', 'info');
            }
        }

        function increaseScrollSpeed() {
            scrollSpeed = Math.min(scrollSpeed + 1, 10);
            updateScrollSpeedDisplay();
        }

        function decreaseScrollSpeed() {
            scrollSpeed = Math.max(scrollSpeed - 1, 1);
            updateScrollSpeedDisplay();
        }

        function setScrollSpeed(value) {
            scrollSpeed = parseInt(value);
            updateScrollSpeedDisplay();
        }

        function updateScrollSpeedDisplay() {
            document.getElementById('scrollSpeedValue').textContent = scrollSpeed + 'x';
            document.getElementById('scrollSpeedSlider').value = scrollSpeed;
        }

        function toggleDrawingTools() {
            if (!pdfDoc) {
                showToast('Önce bir PDF yükleyin!', 'warning');
                return;
            }

            isDrawingMode = !isDrawingMode;
            const toolbar = document.getElementById('drawingToolbar');
            const mainContent = document.getElementById('mainContent');

            if (isDrawingMode) {
                toolbar.classList.add('show');
                mainContent.classList.add('drawing-active');
                createDrawingCanvasesForAllPages();
                updateCursor();
                showToast('Çizim modu aktif - Ultra gelişmiş seçim ve manipülasyon araçları hazır', 'success');
            } else {
                toolbar.classList.remove('show');
                mainContent.classList.remove('drawing-active');
                clearAllSelections();
                finishManipulation();
                updateCursor();
                showToast('Çizim modu kapalı', 'info');
            }
        }

        function createDrawingCanvasesForAllPages() {
            document.querySelectorAll('.pdf-page').forEach(pageDiv => {
                const pageNum = parseInt(pageDiv.getAttribute('data-page-num'));
                const pdfCanvas = pageDiv.querySelector('canvas');
                if (pdfCanvas && !pageDiv.querySelector('.drawing-canvas')) {
                    createDrawingCanvas(pageDiv, pageNum);
                }
            });
        }

        function createDrawingCanvas(pageDiv, pageNum) {
            const existingCanvas = pageDiv.querySelector('.drawing-canvas');
            if (existingCanvas) return;

            const pdfCanvas = pageDiv.querySelector('canvas');
            if (!pdfCanvas) return;

            const drawingCanvas = document.createElement('canvas');
            drawingCanvas.className = 'drawing-canvas';
            drawingCanvas.width = pdfCanvas.width;
            drawingCanvas.height = pdfCanvas.height;
            drawingCanvas.style.position = 'absolute';
            drawingCanvas.style.top = '0';
            drawingCanvas.style.left = '0';
            drawingCanvas.style.width = '100%';
            drawingCanvas.style.height = '100%';
            drawingCanvas.style.pointerEvents = 'none';
            drawingCanvas.style.zIndex = '10';

            const ctx = drawingCanvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            pageDiv.appendChild(drawingCanvas);

            drawingCanvases.set(pageNum, drawingCanvas);
            drawingContexts.set(pageNum, ctx);

            // RESTORE PERSISTENT DRAWINGS
            if (persistentDrawings.has(pageNum)) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = persistentDrawings.get(pageNum);
            }

            setupDrawingEvents(drawingCanvas, pageDiv, pageNum);
        }

        // ULTRA ENHANCED DRAWING EVENTS WITH ALL SHAPES AND TOOLS + NUMBER LINE
        function setupDrawingEvents(canvas, pageDiv, pageNum) {
            let isInteracting = false;
            let lastPoint = null;
            let startPoint = null;
            let tempCanvas = null;
            let currentPath = [];
            let currentDrawingId = null;

            function getCanvasPoint(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                let point = {
                    x: (clientX - rect.left) * (canvas.width / rect.width),
                    y: (clientY - rect.top) * (canvas.height / rect.height)
                };

                return snapToGrid(point);
            }

            function getPagePoint(e) {
                const rect = pageDiv.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            const startInteraction = (e) => {
                if (!isDrawingMode || currentTool === 'hand') return;
                if (e.target.closest('.selection-overlay') || e.target.closest('.manipulation-handle')) return;

                e.preventDefault();
                e.stopPropagation();
                isInteracting = true;
                isDrawing = true;

                let point;
                if (['rectSelect', 'screenshot', 'lasso'].includes(currentTool)) {
                    point = getPagePoint(e);
                } else {
                    point = getCanvasPoint(e);
                }

                lastPoint = point;
                startPoint = point;
                currentDrawingId = Date.now() + '_' + Math.random();

                if (['pen', 'eraser', 'line', 'dashedLine', 'straightLine', 'rectangle', 'circle', 'ellipse', 'arrow', 'highlight', 'triangle', 'rightTriangle', 'pentagon', 'hexagon', 'heptagon', 'star', 'crescent', 'trapezoid', 'parallelogram', 'deltoid', 'cube', 'cone', 'cylinder', 'triangularPrism', 'rectangularPrism', 'numberline'].includes(currentTool)) {
                    saveDrawingState(pageNum);
                }

                if (['line', 'dashedLine', 'straightLine', 'rectangle', 'circle', 'ellipse', 'arrow', 'highlight', 'triangle', 'rightTriangle', 'pentagon', 'hexagon', 'heptagon', 'star', 'crescent', 'trapezoid', 'parallelogram', 'deltoid', 'cube', 'cone', 'cylinder', 'triangularPrism', 'rectangularPrism', 'numberline'].includes(currentTool)) {
                    tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    tempCanvas.style.cssText = canvas.style.cssText;
                    tempCanvas.style.position = 'absolute';
                    tempCanvas.style.zIndex = '11';
                    tempCanvas.style.pointerEvents = 'none';
                    pageDiv.appendChild(tempCanvas);
                } else if (['rectSelect', 'screenshot'].includes(currentTool)) {
                    startNewRectangleSelection(pageDiv, point, pageNum);
                } else if (currentTool === 'lasso') {
                    startNewLassoSelection(pageDiv, point, pageNum);
                    currentPath = [startPoint];
                } else if (currentTool === 'text') {
                    createTextEditor(pageDiv, point, pageNum);
                } else if (currentTool === 'measure') {
                    startMeasurement(pageDiv, point, pageNum);
                }
            };

            const handleInteraction = (e) => {
                if (!isInteracting) return;
                e.preventDefault();
                e.stopPropagation();

                let currentPoint;
                if (['rectSelect', 'screenshot', 'lasso'].includes(currentTool)) {
                    currentPoint = getPagePoint(e);
                } else {
                    currentPoint = getCanvasPoint(e);
                }

                const mainCtx = drawingContexts.get(pageNum);
                if (!mainCtx) return;

                const devicePixelRatio = window.devicePixelRatio || 1;
                const outputScale = devicePixelRatio * scale;

                let thicknessMultiplier = 1;
                if (currentTool === 'highlight') thicknessMultiplier = 8;
                if (currentTool === 'eraser') thicknessMultiplier = 5;

                if (['pen', 'eraser'].includes(currentTool)) {
                    mainCtx.lineWidth = brushSize * outputScale * thicknessMultiplier;
                    mainCtx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
                    mainCtx.strokeStyle = currentColor;
                    mainCtx.globalAlpha = currentOpacity / 100;
                    mainCtx.beginPath();
                    mainCtx.moveTo(lastPoint.x, lastPoint.y);
                    mainCtx.lineTo(currentPoint.x, currentPoint.y);
                    mainCtx.stroke();
                } else if (tempCanvas) {
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.lineWidth = brushSize * outputScale * thicknessMultiplier;
                    tempCtx.globalAlpha = currentOpacity / 100;

                    if (currentTool === 'highlight') {
                        tempCtx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
                        tempCtx.lineCap = 'butt';
                        tempCtx.beginPath();
                        tempCtx.moveTo(startPoint.x, startPoint.y);
                        tempCtx.lineTo(currentPoint.x, currentPoint.y);
                        tempCtx.stroke();
                    } else {
                        drawShape(tempCtx, currentTool, startPoint, currentPoint);
                    }
                } else if (['rectSelect', 'screenshot'].includes(currentTool)) {
                    updateNewRectangleSelection(pageDiv, startPoint, currentPoint, pageNum);
                } else if (currentTool === 'lasso') {
                    currentPath.push(currentPoint);
                    updateNewLassoSelection(pageDiv, currentPath, pageNum);
                } else if (currentTool === 'measure') {
                    updateMeasurement(pageDiv, startPoint, currentPoint, pageNum);
                }

                lastPoint = currentPoint;
            };

            const stopInteraction = () => {
                if (!isInteracting) return;
                isInteracting = false;
                isDrawing = false;

                if (tempCanvas) {
                    const mainCtx = drawingContexts.get(pageNum);
                    if (mainCtx) {
                        let thicknessMultiplier = 1;
                        if (currentTool === 'highlight') thicknessMultiplier = 8;

                        mainCtx.lineWidth = brushSize * scale * devicePixelRatio * thicknessMultiplier;
                        mainCtx.globalAlpha = currentOpacity / 100;

                        if (currentTool === 'highlight') {
                            mainCtx.globalCompositeOperation = 'multiply';
                            mainCtx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
                            mainCtx.lineCap = 'butt';
                            mainCtx.beginPath();
                            mainCtx.moveTo(startPoint.x, startPoint.y);
                            mainCtx.lineTo(lastPoint.x, lastPoint.y);
                            mainCtx.stroke();
                        } else {
                            mainCtx.globalCompositeOperation = 'source-over';
                            drawShape(mainCtx, currentTool, startPoint, lastPoint);
                        }

                        // SAVE TO PERSISTENT DRAWINGS
                        persistentDrawings.set(pageNum, canvas.toDataURL());
                    }
                    tempCanvas.remove();
                    tempCanvas = null;
                }

                if (currentTool === 'rectSelect') {
                    finishNewRectangleSelection(pageDiv, false, pageNum);
                } else if (currentTool === 'screenshot') {
                    finishNewRectangleSelection(pageDiv, true, pageNum);
                } else if (currentTool === 'lasso') {
                    finishNewLassoSelection(pageDiv, currentPath, pageNum);
                } else if (currentTool === 'measure') {
                    finishMeasurement(pageDiv, startPoint, lastPoint, pageNum);
                }

                // SAVE TO PERSISTENT DRAWINGS FOR ALL DRAWING TOOLS
                if (['pen', 'eraser'].includes(currentTool)) {
                    persistentDrawings.set(pageNum, canvas.toDataURL());
                }
            };

            pageDiv.addEventListener('mousedown', startInteraction);
            pageDiv.addEventListener('mousemove', handleInteraction);
            window.addEventListener('mouseup', stopInteraction);
            pageDiv.addEventListener('touchstart', startInteraction, { passive: false });
            pageDiv.addEventListener('touchmove', handleInteraction, { passive: false });
            window.addEventListener('touchend', stopInteraction, { passive: false });
        }

        // ULTRA ENHANCED SELECTION TOOLS WITH FULL MANIPULATION
        function startNewRectangleSelection(pageDiv, startPoint, pageNum) {
            clearAllSelections();

            const overlay = document.createElement('div');
            overlay.className = 'new-selection-overlay';
            overlay.style.position = 'absolute';
            overlay.style.border = '2px dashed #3498db';
            overlay.style.background = 'rgba(52, 152, 219, 0.1)';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '15';
            overlay.style.left = startPoint.x + 'px';
            overlay.style.top = startPoint.y + 'px';
            overlay.style.width = '0px';
            overlay.style.height = '0px';
            overlay.dataset.pageNum = pageNum;

            pageDiv.appendChild(overlay);

            const selectionData = {
                overlay: overlay,
                startPoint: startPoint,
                pageDiv: pageDiv,
                pageNum: pageNum,
                isScreenshot: currentTool === 'screenshot'
            };

            activeSelections.set(pageNum, selectionData);

            showToast(currentTool === 'screenshot' ? 'Ekran alıntısı seçimi başladı' : 'Dikdörtgen seçim başladı', 'info');
        }

        function updateNewRectangleSelection(pageDiv, startPoint, currentPoint, pageNum) {
            const selection = activeSelections.get(pageNum);
            if (!selection || !selection.overlay) return;

            const minX = Math.min(startPoint.x, currentPoint.x);
            const minY = Math.min(startPoint.y, currentPoint.y);
            const width = Math.abs(currentPoint.x - startPoint.x);
            const height = Math.abs(currentPoint.y - startPoint.y);

            const overlay = selection.overlay;
            overlay.style.left = minX + 'px';
            overlay.style.top = minY + 'px';
            overlay.style.width = width + 'px';
            overlay.style.height = height + 'px';
        }

        function finishNewRectangleSelection(pageDiv, isScreenshot, pageNum) {
            const selection = activeSelections.get(pageNum);
            if (!selection || !selection.overlay) return;

            const overlay = selection.overlay;
            const rect = overlay.getBoundingClientRect();
            const pageRect = pageDiv.getBoundingClientRect();

            // Minimum seçim boyutu kontrolü
            if (rect.width < 10 || rect.height < 10) {
                overlay.remove();
                activeSelections.delete(pageNum);
                showToast('Seçim çok küçük', 'warning');
                return;
            }

            if (isScreenshot) {
                // Ekran alıntısı için otomatik clipboard kopyalama
                captureSelectionToClipboard(pageDiv, overlay, pageNum);
                overlay.remove();
                activeSelections.delete(pageNum);
            } else {
                // Normal dikdörtgen seçim için manipülasyon handles ekle
                addManipulationHandles(overlay, pageNum);
                showToast('Seçim tamamlandı - Manipülasyon için handles eklendi', 'success');
            }
        }

        // YENİ LASSO SEÇİM ARAÇLARI
        function startNewLassoSelection(pageDiv, startPoint, pageNum) {
            clearAllSelections();

            const pathSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            pathSvg.className = 'lasso-selection-svg';
            pathSvg.style.position = 'absolute';
            pathSvg.style.top = '0';
            pathSvg.style.left = '0';
            pathSvg.style.width = '100%';
            pathSvg.style.height = '100%';
            pathSvg.style.pointerEvents = 'none';
            pathSvg.style.zIndex = '15';

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('stroke', '#3498db');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-dasharray', '5,5');
            path.setAttribute('fill', 'rgba(52, 152, 219, 0.1)');
            path.setAttribute('d', `M ${startPoint.x} ${startPoint.y}`);

            pathSvg.appendChild(path);
            pageDiv.appendChild(pathSvg);

            const selectionData = {
                svg: pathSvg,
                path: path,
                pathPoints: [startPoint],
                startPoint: startPoint,
                pageDiv: pageDiv,
                pageNum: pageNum
            };

            activeSelections.set(pageNum, selectionData);
            showToast('Lasso seçimi başladı - Çizerek seçin', 'info');
        }

        function updateNewLassoSelection(pageDiv, pathPoints, pageNum) {
            const selection = activeSelections.get(pageNum);
            if (!selection || !selection.path) return;

            selection.pathPoints = pathPoints;

            let pathData = `M ${pathPoints[0].x} ${pathPoints[0].y}`;
            for (let i = 1; i < pathPoints.length; i++) {
                pathData += ` L ${pathPoints[i].x} ${pathPoints[i].y}`;
            }

            selection.path.setAttribute('d', pathData);
        }

        function finishNewLassoSelection(pageDiv, pathPoints, pageNum) {
            const selection = activeSelections.get(pageNum);
            if (!selection || pathPoints.length < 10) {
                if (selection && selection.svg) {
                    selection.svg.remove();
                }
                activeSelections.delete(pageNum);
                showToast('Lasso seçimi çok kısa', 'warning');
                return;
            }

            const mainCanvas = drawingCanvases.get(pageNum);
            const mainCtx = drawingContexts.get(pageNum);
            if (!mainCanvas || !mainCtx) return;

            saveDrawingState(pageNum);
            originalCanvasState = mainCanvas.toDataURL();

            const minX = Math.min(...pathPoints.map(p => p.x));
            const maxX = Math.max(...pathPoints.map(p => p.x));
            const minY = Math.min(...pathPoints.map(p => p.y));
            const maxY = Math.max(...pathPoints.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;

            if (width < 10 || height < 10) {
                selection.svg.remove();
                activeSelections.delete(pageNum);
                showToast('Seçim çok küçük', 'warning');
                return;
            }

            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = width;
            maskCanvas.height = height;
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.beginPath();
            maskCtx.moveTo(pathPoints[0].x - minX, pathPoints[0].y - minY);
            for (let i = 1; i < pathPoints.length; i++) {
                maskCtx.lineTo(pathPoints[i].x - minX, pathPoints[i].y - minY);
            }
            maskCtx.closePath();
            maskCtx.fillStyle = 'black';
            maskCtx.fill();

            capturedImageData = document.createElement('canvas');
            capturedImageData.width = width;
            capturedImageData.height = height;
            const capturedCtx = capturedImageData.getContext('2d');
            capturedCtx.drawImage(mainCanvas, minX, minY, width, height, 0, 0, width, height);
            capturedCtx.globalCompositeOperation = 'destination-in';
            capturedCtx.drawImage(maskCanvas, 0, 0);

            mainCtx.save();
            mainCtx.globalCompositeOperation = 'destination-out';
            const path2D = new Path2D(selection.path.getAttribute('d'));
            mainCtx.fillStyle = 'black';
            mainCtx.fill(path2D);
            mainCtx.restore();

            manipulationCanvas = document.createElement('canvas');
            manipulationCanvas.width = mainCanvas.width;
            manipulationCanvas.height = mainCanvas.height;
            manipulationCanvas.style.cssText = mainCanvas.style.cssText;
            manipulationCanvas.style.position = 'absolute';
            manipulationCanvas.style.zIndex = '12';
            manipulationCanvas.style.pointerEvents = 'none';
            pageDiv.appendChild(manipulationCanvas);

            selection.svg.remove();

            const overlay = document.createElement('div');
            overlay.className = 'lasso-selection-overlay';
            overlay.style.position = 'absolute';
            overlay.style.border = '2px dashed #e74c3c';
            overlay.style.left = minX + 'px';
            overlay.style.top = minY + 'px';
            overlay.style.width = width + 'px';
            overlay.style.height = height + 'px';
            overlay.style.zIndex = '16';
            overlay.style.transformOrigin = 'center center';

            pageDiv.appendChild(overlay);

            selection.boundingOverlay = overlay;
            selection.boundingRect = { x: minX, y: minY, width: width, height: height };

            manipulationCanvas.getContext('2d').drawImage(capturedImageData, minX, minY);

            addManipulationHandles(overlay, pageNum);
            showToast('Lasso seçimi tamamlandı - Şimdi taşıyabilir, döndürebilir ve boyutlandırabilirsiniz', 'success');

            isManipulating = true;
            manipulationData = selection;
        }

        // TEXT EDITOR FUNCTIONALITY
        function createTextEditor(pageDiv, point, pageNum) {
            const textEditor = document.createElement('div');
            textEditor.className = 'text-editor';
            textEditor.style.left = point.x + 'px';
            textEditor.style.top = point.y + 'px';
            textEditor.innerHTML = `
                <textarea placeholder="Metin girin..." style="font-size: ${brushSize + 10}px; color: ${currentColor}; opacity: ${currentOpacity / 100};"></textarea>
            `;

            pageDiv.appendChild(textEditor);
            textEditors.set(pageNum + '_' + Date.now(), textEditor);

            const textarea = textEditor.querySelector('textarea');
            textarea.focus();

            textarea.addEventListener('blur', () => {
                if (textarea.value.trim()) {
                    finalizeTextEditor(textEditor, pageNum);
                } else {
                    textEditor.remove();
                }
            });

            showToast('Metin editörü açıldı - Yazmaya başlayın', 'info');
        }

        function finalizeTextEditor(textEditor, pageNum) {
            const textarea = textEditor.querySelector('textarea');
            const text = textarea.value.trim();

            if (text) {
                const canvas = drawingCanvases.get(pageNum);
                const ctx = drawingContexts.get(pageNum);

                if (canvas && ctx) {
                    const rect = textEditor.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();

                    const x = (rect.left - canvasRect.left) * (canvas.width / canvasRect.width);
                    const y = (rect.top - canvasRect.top) * (canvas.height / canvasRect.height);

                    ctx.font = `${brushSize + 10}px Arial`;
                    ctx.fillStyle = currentColor;
                    ctx.globalAlpha = currentOpacity / 100;
                    ctx.fillText(text, x, y + brushSize + 10);

                    saveDrawingState(pageNum);

                    // SAVE TO PERSISTENT DRAWINGS
                    persistentDrawings.set(pageNum, canvas.toDataURL());

                    showToast('Metin eklendi', 'success');
                }
            }

            textEditor.remove();
        }

        // MEASUREMENT FUNCTIONALITY
        function updateMeasurement(pageDiv, start, current, pageNum) {
            const distance = Math.sqrt(Math.pow(current.x - start.x, 2) + Math.pow(current.y - start.y, 2));
            const distanceCm = (distance / scale / 96 * 2.54).toFixed(2);

            pageDiv.querySelectorAll('.measurement-line, .measurement-label').forEach(el => el.remove());

            const line = document.createElement('div');
            line.className = 'measurement-line';
            const angle = Math.atan2(current.y - start.y, current.x - start.x) * 180 / Math.PI;
            const length = Math.sqrt(Math.pow(current.x - start.x, 2) + Math.pow(current.y - start.y, 2));

            line.style.left = start.x + 'px';
            line.style.top = start.y + 'px';
            line.style.width = length + 'px';
            line.style.transform = `rotate(${angle}deg)`;

            const label = document.createElement('div');
            label.className = 'measurement-label';
            label.textContent = `${distanceCm} cm`;
            label.style.left = (start.x + current.x) / 2 + 'px';
            label.style.top = (start.y + current.y) / 2 - 20 + 'px';

            pageDiv.appendChild(line);
            pageDiv.appendChild(label);
        }

        function finishMeasurement(pageDiv, start, end, pageNum) {
            const distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            const distanceCm = (distance / scale / 96 * 2.54).toFixed(2);

            showToast(`Ölçüm tamamlandı: ${distanceCm} cm`, 'success');
        }

        // ULTRA ENHANCED MANIPULATION HANDLES AND EVENTS
        function addManipulationHandles(overlay, pageNum) {
            overlay.querySelectorAll('.manipulation-handle').forEach(handle => handle.remove());

            const handles = [
                { class: 'handle-nw', cursor: 'nw-resize' },
                { class: 'handle-ne', cursor: 'ne-resize' },
                { class: 'handle-sw', cursor: 'sw-resize' },
                { class: 'handle-se', cursor: 'se-resize' },
                { class: 'handle-n', cursor: 'n-resize' },
                { class: 'handle-s', cursor: 's-resize' },
                { class: 'handle-w', cursor: 'w-resize' },
                { class: 'handle-e', cursor: 'e-resize' },
                { class: 'handle-rotate', cursor: 'pointer' },
                { class: 'handle-move', cursor: 'move' }
            ];

            handles.forEach(({ class: className, cursor }) => {
                const handle = document.createElement('div');
                handle.className = `manipulation-handle ${className}`;
                handle.style.cursor = cursor;
                handle.dataset.handleType = className.replace('handle-', '');
                overlay.appendChild(handle);
            });

            createManipulationToolbar(overlay);
            setupManipulationEvents(overlay);
        }

        function createManipulationToolbar(overlay) {
            const existingToolbar = overlay.querySelector('.manipulation-toolbar');
            if (existingToolbar) existingToolbar.remove();

            const toolbar = document.createElement('div');
            toolbar.className = 'manipulation-toolbar';
            toolbar.innerHTML = `
                <button class="manipulation-tool-btn" onclick="flipHorizontal()" title="Yatay Çevir">
                    <i class="fas fa-arrows-alt-h"></i>
                </button>
                <button class="manipulation-tool-btn" onclick="flipVertical()" title="Dikey Çevir">
                    <i class="fas fa-arrows-alt-v"></i>
                </button>
                <button class="manipulation-tool-btn confirm" onclick="confirmManipulation()" title="Onayla (Enter)">
                    <i class="fas fa-check"></i>
                </button>
                <button class="manipulation-tool-btn cancel" onclick="cancelManipulation()" title="İptal Et (Esc)">
                    <i class="fas fa-times"></i>
                </button>
            `;

            overlay.appendChild(toolbar);
        }

        function setupManipulationEvents(overlay) {
            let isDragging = false;
            let isResizing = false;
            let isRotating = false;
            let startMousePos = null;
            let startOverlayPos = null;
            let startOverlaySize = null;
            let startRotation = 0;

            overlay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                const handle = e.target.closest('.manipulation-handle');
                if (handle) {
                    const handleType = handle.dataset.handleType;
                    currentManipulationHandle = handleType;

                    startMousePos = { x: e.clientX, y: e.clientY };
                    startOverlayPos = {
                        x: parseInt(overlay.style.left),
                        y: parseInt(overlay.style.top)
                    };
                    startOverlaySize = {
                        width: parseInt(overlay.style.width),
                        height: parseInt(overlay.style.height)
                    };
                    startRotation = currentRotation;

                    if (handleType === 'move') {
                        isDragging = true;
                        overlay.style.cursor = 'grabbing';
                    } else if (handleType === 'rotate') {
                        isRotating = true;
                        overlay.style.cursor = 'grabbing';
                    } else {
                        isResizing = true;
                    }

                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                }
            });

            function handleMouseMove(e) {
                if (!startMousePos || !isManipulating) return;

                const manipCtx = manipulationCanvas.getContext('2d');
                manipCtx.clearRect(0, 0, manipulationCanvas.width, manipulationCanvas.height);

                const deltaX = e.clientX - startMousePos.x;
                const deltaY = e.clientY - startMousePos.y;

                let newX = startOverlayPos.x;
                let newY = startOverlayPos.y;
                let newWidth = startOverlaySize.width;
                let newHeight = startOverlaySize.height;

                let transformMatrix = {
                    translateX: startOverlayPos.x + (startOverlaySize.width / 2),
                    translateY: startOverlayPos.y + (startOverlaySize.height / 2),
                    scaleX: isFlippedHorizontal ? -1 : 1,
                    scaleY: isFlippedVertical ? -1 : 1,
                    rotation: currentRotation,
                };

                if (isDragging) {
                    newX = startOverlayPos.x + deltaX;
                    newY = startOverlayPos.y + deltaY;
                    transformMatrix.translateX = newX + newWidth / 2;
                    transformMatrix.translateY = newY + newHeight / 2;
                } else if (isResizing) {
                    const isShiftPressed = e.shiftKey;
                    switch (currentManipulationHandle) {
                        case 'se':
                            newWidth = Math.max(20, startOverlaySize.width + deltaX);
                            newHeight = Math.max(20, startOverlaySize.height + deltaY);
                            if (isShiftPressed) { newHeight = newWidth / (startOverlaySize.width/startOverlaySize.height); }
                            break;
                        case 'sw':
                            newWidth = Math.max(20, startOverlaySize.width - deltaX);
                            newHeight = Math.max(20, startOverlaySize.height + deltaY);
                            newX = startOverlayPos.x + deltaX;
                            if (isShiftPressed) { newHeight = newWidth / (startOverlaySize.width/startOverlaySize.height); }
                            break;
                        case 'ne':
                            newWidth = Math.max(20, startOverlaySize.width + deltaX);
                            newHeight = Math.max(20, startOverlaySize.height - deltaY);
                            newY = startOverlayPos.y + deltaY;
                            if (isShiftPressed) { const ratio = startOverlaySize.width / startOverlaySize.height; const oldHeight = newHeight; newHeight = newWidth / ratio; newY += oldHeight - newHeight; }
                            break;
                        case 'nw':
                            newWidth = Math.max(20, startOverlaySize.width - deltaX);
                            newHeight = Math.max(20, startOverlaySize.height - deltaY);
                            newX = startOverlayPos.x + deltaX;
                            newY = startOverlayPos.y + deltaY;
                            if (isShiftPressed) { const ratio = startOverlaySize.width / startOverlaySize.height; const oldHeight = newHeight; newHeight = newWidth / ratio; newY += oldHeight - newHeight; }
                            break;
                        case 'n': newHeight = Math.max(20, startOverlaySize.height - deltaY); newY = startOverlayPos.y + deltaY; break;
                        case 's': newHeight = Math.max(20, startOverlaySize.height + deltaY); break;
                        case 'w': newWidth = Math.max(20, startOverlaySize.width - deltaX); newX = startOverlayPos.x + deltaX; break;
                        case 'e': newWidth = Math.max(20, startOverlaySize.width + deltaX); break;
                    }

                    transformMatrix.scaleX *= newWidth / startOverlaySize.width;
                    transformMatrix.scaleY *= newHeight / startOverlaySize.height;
                    transformMatrix.translateX = newX + newWidth / 2;
                    transformMatrix.translateY = newY + newHeight / 2;

                } else if (isRotating) {
                    const centerX = startOverlayPos.x + startOverlaySize.width / 2;
                    const centerY = startOverlayPos.y + startOverlaySize.height / 2;
                    const startAngle = Math.atan2(startMousePos.y - centerY, startMousePos.x - centerX);
                    const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    let rotation_delta = (currentAngle - startAngle) * (180 / Math.PI);
                    let newRotation = startRotation + rotation_delta;
                    if (e.ctrlKey) {
                        newRotation = Math.round(newRotation / 15) * 15;
                    }
                    currentRotation = newRotation;
                    transformMatrix.rotation = currentRotation;
                }

                overlay.style.left = `${newX}px`;
                overlay.style.top = `${newY}px`;
                overlay.style.width = `${newWidth}px`;
                overlay.style.height = `${newHeight}px`;
                overlay.style.transform = `rotate(${currentRotation}deg)`;

                manipCtx.save();
                manipCtx.translate(transformMatrix.translateX, transformMatrix.translateY);
                manipCtx.rotate(transformMatrix.rotation * Math.PI / 180);
                manipCtx.scale(transformMatrix.scaleX, transformMatrix.scaleY);
                manipCtx.drawImage(capturedImageData, -startOverlaySize.width / 2, -startOverlaySize.height / 2, startOverlaySize.width, startOverlaySize.height);
                manipCtx.restore();
            }

            function handleMouseUp(e) {
                isDragging = false;
                isResizing = false;
                isRotating = false;
                currentManipulationHandle = null;
                startMousePos = null;
                startOverlayPos = null;
                startOverlaySize = null;
                overlay.style.cursor = '';

                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                showToast('Manipülasyon tamamlandı - Onayla veya İptal et', 'info');
            }
        }

        function flipHorizontal() {
            if (!isManipulating) return;
            isFlippedHorizontal = !isFlippedHorizontal;
            redrawManipulationCanvas();
            showToast('Yatay çevrildi', 'success');
        }

        function flipVertical() {
            if (!isManipulating) return;
            isFlippedVertical = !isFlippedVertical;
            redrawManipulationCanvas();
            showToast('Dikey çevrildi', 'success');
        }

        function redrawManipulationCanvas() {
            if (!isManipulating || !manipulationCanvas || !manipulationData) return;

            const overlay = manipulationData.boundingOverlay;
            const manipCtx = manipulationCanvas.getContext('2d');
            manipCtx.clearRect(0, 0, manipulationCanvas.width, manipulationCanvas.height);

            const currentWidth = parseFloat(overlay.style.width);
            const currentHeight = parseFloat(overlay.style.height);
            const currentX = parseFloat(overlay.style.left);
            const currentY = parseFloat(overlay.style.top);

            const scaleX = currentWidth / manipulationData.boundingRect.width * (isFlippedHorizontal ? -1 : 1);
            const scaleY = currentHeight / manipulationData.boundingRect.height * (isFlippedVertical ? -1 : 1);

            manipCtx.save();
            manipCtx.translate(currentX + currentWidth / 2, currentY + currentHeight / 2);
            manipCtx.rotate(currentRotation * Math.PI / 180);
            manipCtx.scale(scaleX, scaleY);
            manipCtx.drawImage(capturedImageData, -manipulationData.boundingRect.width / 2, -manipulationData.boundingRect.height / 2, manipulationData.boundingRect.width, manipulationData.boundingRect.height);
            manipCtx.restore();
        }

        function confirmManipulation() {
            if (!isManipulating || !manipulationData) return;

            const pageNum = manipulationData.pageNum;
            const mainCtx = drawingContexts.get(pageNum);

            mainCtx.drawImage(manipulationCanvas, 0, 0);

            persistentDrawings.set(pageNum, drawingCanvases.get(pageNum).toDataURL());
            saveDrawingState(pageNum);

            cleanupManipulation();
            showToast('Değişiklikler onaylandı ve uygulandı', 'success');
        }

        function cancelManipulation() {
            if (!isManipulating || !manipulationData || !originalCanvasState) return;

            const pageNum = manipulationData.pageNum;
            const mainCanvas = drawingCanvases.get(pageNum);
            const mainCtx = drawingContexts.get(pageNum);

            const img = new Image();
            img.onload = () => {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                mainCtx.drawImage(img, 0, 0);
            };
            img.src = originalCanvasState;

            cleanupManipulation();
            showToast('Değişiklikler iptal edildi', 'info');
        }

        function cleanupManipulation() {
            if (manipulationData && manipulationData.boundingOverlay) {
                manipulationData.boundingOverlay.remove();
            }
            if (manipulationCanvas) {
                manipulationCanvas.remove();
            }

            isManipulating = false;
            manipulationData = null;
            manipulationCanvas = null;
            capturedImageData = null;
            originalCanvasState = null;
            currentRotation = 0;
            isFlippedHorizontal = false;
            isFlippedVertical = false;

            document.querySelectorAll('.selection-overlay, .new-selection-overlay, .lasso-selection-overlay, .lasso-selection-svg, .manipulation-handle, .manipulation-toolbar').forEach(overlay => {
                overlay.remove();
            });
            activeSelections.clear();
            updateSelectionCount();
        }

        function finishManipulation() {
            if (isManipulating) {
                cancelManipulation();
            }
        }

        function clearAllSelections() {
            if (isManipulating) {
                cancelManipulation();
                return;
            }

            document.querySelectorAll('.selection-overlay, .new-selection-overlay, .lasso-selection-overlay, .lasso-selection-svg, .manipulation-handle, .manipulation-toolbar').forEach(overlay => {
                overlay.remove();
            });

            activeSelections.clear();
            updateSelectionCount();
        }

        function captureSelectionToClipboard(pageDiv, overlay, pageNum) {
            const canvas = pageDiv.querySelector('canvas');
            if (!canvas) {
                showToast('PDF canvas bulunamadı', 'error');
                return;
            }

            const rect = overlay.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();

            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;

            const x = Math.max(0, (rect.left - canvasRect.left) * scaleX);
            const y = Math.max(0, (rect.top - canvasRect.top) * scaleY);
            const width = Math.min(canvas.width - x, rect.width * scaleX);
            const height = Math.min(canvas.height - y, rect.height * scaleY);

            const screenshotCanvas = document.createElement('canvas');
            screenshotCanvas.width = width;
            screenshotCanvas.height = height;
            const ctx = screenshotCanvas.getContext('2d');

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

            const drawingCanvas = pageDiv.querySelector('.drawing-canvas');
            if (drawingCanvas) {
                ctx.drawImage(drawingCanvas, x, y, width, height, 0, 0, width, height);
            }

            screenshotCanvas.toBlob(async (blob) => {
                try {
                    if (navigator.clipboard && window.ClipboardItem) {
                        const item = new ClipboardItem({ 'image/png': blob });
                        await navigator.clipboard.write([item]);

                        showClipboardNotification();
                        showToast('✓ Seçim başarıyla panoya kopyalandı! (Ctrl+V ile yapıştırın)', 'success');

                        overlay.style.animation = 'flash 0.3s ease-in-out';
                        setTimeout(() => {
                            if (overlay.parentNode) overlay.style.animation = '';
                        }, 300);

                    } else {
                        downloadScreenshot(screenshotCanvas);
                        showToast('Clipboard desteklenmiyor - Görüntü indirildi', 'warning');
                    }
                } catch (error) {
                    console.error('Clipboard kopyalama hatası:', error);
                    downloadScreenshot(screenshotCanvas);
                    showToast('Clipboard hatası - Görüntü indirildi', 'warning');
                }
            }, 'image/png', 1.0);
        }

        function downloadScreenshot(canvas) {
            const link = document.createElement('a');
            link.download = `ekran_alintisi_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
            showToast('Ekran alıntısı Ultra HD kalitede indirildi', 'success');
        }

        function selectTool(tool) {
            currentTool = tool;

            document.querySelectorAll('.drawing-tool').forEach(btn => btn.classList.remove('active'));
            const toolButton = document.getElementById(tool + 'Tool');
            if (toolButton) {
                toolButton.classList.add('active');

                toolButton.style.animation = 'pulse 0.3s ease';
                setTimeout(() => {
                    toolButton.style.animation = '';
                }, 300);
            }

            clearAllSelections();
            finishManipulation();

            document.querySelectorAll('.drawing-canvas').forEach(canvas => {
                canvas.style.pointerEvents = 'auto';
                if (['pen', 'eraser', 'highlight', 'rectSelect', 'lasso', 'screenshot', 'text', 'measure', 'numberline', 'line', 'dashedLine', 'straightLine', 'rectangle', 'circle', 'ellipse', 'arrow', 'triangle', 'rightTriangle', 'pentagon', 'hexagon', 'heptagon', 'star', 'crescent', 'trapezoid', 'parallelogram', 'deltoid', 'cube', 'cone', 'cylinder', 'triangularPrism', 'rectangularPrism'].includes(tool)) {
                    canvas.classList.add('active');
                } else {
                    canvas.classList.remove('active');
                }
            });

            updateCursor();

            const toolTips = {
                'rectSelect': 'Sürükleyerek dikdörtgen seçim yapın - 360° döndürme ve 8-nokta boyutlandırma',
                'lasso': 'Serbest şekilde çizerek lasso seçimi yapın - Otomatik kapatılır',
                'selectDelete': 'Seçim yaparak çizimleri silin',
                'screenshot': 'Seçim yaptığınız alan otomatik clipboard\'a kopyalanır',
                'crescent': 'Gerçek Türk bayrağı hilali çizer',
                'triangle': 'Dik üçgen çizin',
                'rightTriangle': 'Dik açı işaretli üçgen çizin',
                'line': 'İki yönlü oklu doğru çizin',
                'straightLine': 'İki yönlü oklu doğru çizin',
                'measure': 'İki nokta arasında ölçüm yapın',
                'pen': 'Serbest çizim için fare veya dokunmatik kullanın',
                'eraser': 'Çizimleri silmek için kullanın',
                'highlight': 'Metinleri vurgulamak için kullanın'
            };

            const tip = toolTips[tool] || `${getToolName(tool)} aracı seçildi`;
            showToast(tip, 'info');
        }

        function updateCursor() {
            document.body.className = document.body.className.replace(/\bcursor-\w+\b/g, '').trim();

            if (isDrawingMode) {
                const cursorClass = `cursor-${currentTool}`;
                if (currentTool !== 'hand') {
                     document.body.classList.add(cursorClass);
                }
            }
        }

        function selectColor(color) {
            currentColor = color;

            document.querySelectorAll('.color-picker').forEach(picker => picker.classList.remove('active'));
            event.target.classList.add('active');

            showToast(`Renk: ${color}`, 'info');
        }

        function getToolName(tool) {
            const names = {
                'pen': 'Kalem',
                'eraser': 'Silgi',
                'highlight': 'Fosforlu Kalem',
                'hand': 'El',
                'rectSelect': 'Dikdörtgen Seçim',
                'lasso': 'Lasso Seçim',
                'screenshot': 'Ekran Alıntısı',
                'text': 'Metin',
                'measure': 'Ölçüm',
                'numberline': 'Sayı Doğrusu',
                'line': 'Çizgi',
                'straightLine': 'Doğru',
                'dashedLine':  'Kesikli Çizgi',
                'rectangle': 'Dikdörtgen',
                'circle': 'Daire',
                'ellipse': 'Elips',
                'arrow': 'Ok',
                'triangle': 'Üçgen',
                'rightTriangle': 'Dik Üçgen',
                'pentagon': 'Beşgen',
                'hexagon': 'Altıgen',
                'heptagon': 'Yedigen',
                'star': 'Yıldız',
                'crescent': 'Hilal',
                'trapezoid': 'Yamuk',
                'parallelogram': 'Paralelkenar',
                'deltoid': 'Deltoid',
                'cube': 'Küp',
                'cone': 'Koni',
                'cylinder': 'Silindir',
                'triangularPrism': 'Üçgen Prizma',
                'rectangularPrism': 'Dikdörtgen Prizma'
            };
            return names[tool] || tool;
        }

        function saveDrawingState(pageNum) {
            const canvas = drawingCanvases.get(pageNum);
            if (canvas) {
                const imageData = canvas.toDataURL();
                if (!undoStack[pageNum]) undoStack[pageNum] = [];
                undoStack[pageNum].push(imageData);

                if (undoStack[pageNum].length > 15) {
                    undoStack[pageNum].shift();
                }

                redoStack[pageNum] = [];
            }
        }

        function undoDrawing() {
            const currentPageNum = getCurrentVisiblePage();
            if (!undoStack[currentPageNum] || undoStack[currentPageNum].length === 0) {
                showToast('Geri alınacak işlem yok', 'warning');
                return;
            }

            const canvas = drawingCanvases.get(currentPageNum);
            const ctx = drawingContexts.get(currentPageNum);

            if (canvas && ctx) {
                if (!redoStack[currentPageNum]) redoStack[currentPageNum] = [];
                redoStack[currentPageNum].push(canvas.toDataURL());

                const previousState = undoStack[currentPageNum].pop();
                if (previousState) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);

                        persistentDrawings.set(currentPageNum, canvas.toDataURL());
                    };
                    img.src = previousState;
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    persistentDrawings.delete(currentPageNum);
                }

                showToast('Çizim geri alındı', 'success');
            }
        }

        function redoDrawing() {
            const currentPageNum = getCurrentVisiblePage();
            if (!redoStack[currentPageNum] || redoStack[currentPageNum].length === 0) {
                showToast('İleri alınacak işlem yok', 'warning');
                return;
            }

            const canvas = drawingCanvases.get(currentPageNum);
            const ctx = drawingContexts.get(currentPageNum);

            if (canvas && ctx) {
                const currentState = canvas.toDataURL();
                if (!undoStack[currentPageNum]) undoStack[currentPageNum] = [];
                undoStack[currentPageNum].push(currentState);

                const nextState = redoStack[currentPageNum].pop();
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);

                    persistentDrawings.set(currentPageNum, canvas.toDataURL());
                };
                img.src = nextState;

                showToast('Çizim ileri alındı', 'success');
            }
        }

        function clearAllDrawing() {
            if (confirm('Tüm sayfalardan çizimleri temizlemek istediğinizden emin misiniz?')) {
                drawingContexts.forEach((ctx, pageNum) => {
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    saveDrawingState(pageNum);
                });
                clearAllSelections();
                finishManipulation();
                highlights.clear();
                measurements.clear();
                textEditors.clear();
                numberLines.clear();
                selectedDrawings.clear();
                persistentDrawings.clear();
                updateSelectionCount();
                showToast('Tüm çizimler temizlendi', 'success');
            }
        }

        function saveDrawing() {
            const currentPageNum = getCurrentVisiblePage();
            const canvas = drawingCanvases.get(currentPageNum);

            if (canvas) {
                const link = document.createElement('a');
                link.download =`sayfa_${currentPageNum}_cizim_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();
                showToast(`Sayfa ${currentPageNum} çizimi Ultra HD kalitede kaydedildi`, 'success');
            } else {
                showToast('Kaydedilecek çizim bulunamadı', 'warning');
            }
        }

        function getCurrentVisiblePage() {
            updateCurrentPageFromScroll();
            return currentPage;
        }

        function addHighlightOverlay(pageDiv, highlight) {
            const overlay = document.createElement('div');
            overlay.className = 'highlight-overlay';
            overlay.style.left = highlight.x + 'px';
            overlay.style.top = highlight.y + 'px';
            overlay.style.width = highlight.width + 'px';
            overlay.style.height = highlight.height + 'px';
            overlay.style.background = highlight.color;

            pageDiv.appendChild(overlay);
        }

        // Search Functions
        function openSearchModal(event) {
            if (event) event.stopPropagation();
            if (!pdfDoc) {
                showToast('Önce bir PDF yükleyin!', 'warning');
                return;
            }

            document.getElementById('searchModal').classList.add('show');
            document.getElementById('searchInput').focus();
        }

        function closeSearchModal() {
            document.getElementById('searchModal').classList.remove('show');
            document.getElementById('searchInput').value = '';
            hideSearchResults();
        }

        // Enhanced high-performance search with caching and debouncing
        let searchTimeout = null;
        let lastSearchQuery = '';

        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                performSearchOptimized();
            }
        }

        async function performSearch() {
            performSearchOptimized();
        }

        async function performSearchOptimized() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) {
                showToast('Arama terimi girin!', 'warning');
                return;
            }

            // Debounce search to prevent excessive calls
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }

            searchTimeout = setTimeout(async () => {
                await executeOptimizedSearch(query);
            }, 200);
        }

        async function executeOptimizedSearch(query) {
            const lowerQuery = query.toLowerCase();

            // Check cache first
            if (searchCache.has(lowerQuery)) {
                const cachedResults = searchCache.get(lowerQuery);
                searchResults = cachedResults;
                if (searchResults.length > 0) {
                    showToast(`${searchResults.length} sonuç bulundu (önbellek)`, 'success');
                    currentSearchIndex = 0;
                    displaySearchResults();
                    goToPage(searchResults[0].pageNum);
                } else {
                    showToast('Sonuç bulunamadı', 'info');
                }
                return;
            }

            showLoading('Hızlı arama yapılıyor...', 0);
            searchResults = [];
            currentSearchIndex = -1;
            lastSearchQuery = lowerQuery;

            try {
                // Use batch processing for better performance
                const batchSize = 3;
                const totalBatches = Math.ceil(totalPages / batchSize);

                for (let batch = 0; batch < totalBatches; batch++) {
                    const promises = [];
                    const startPage = batch * batchSize + 1;
                    const endPage = Math.min(startPage + batchSize - 1, totalPages);

                    // Process pages in parallel within each batch
                    for (let pageNum = startPage; pageNum <= endPage; pageNum++) {
                        promises.push(searchInPageOptimized(pageNum, query, lowerQuery));
                    }

                    const batchResults = await Promise.all(promises);

                    // Flatten and add results
                    batchResults.forEach(pageResults => {
                        if (pageResults && pageResults.length > 0) {
                            searchResults.push(...pageResults);
                        }
                    });

                    // Update progress
                    const progress = Math.round(((batch + 1) / totalBatches) * 100);
                    updateProgress(progress);

                    // Allow UI to breathe between batches
                    await new Promise(resolve => setTimeout(resolve, 5));
                }

                hideLoading();

                // Cache results for future searches
                searchCache.set(lowerQuery, [...searchResults]);

                if (searchResults.length > 0) {
                    showToast(`${searchResults.length} sonuç bulundu`, 'success');
                    currentSearchIndex = 0;
                    displaySearchResults();
                    goToPage(searchResults[0].pageNum);
                } else {
                    showToast('Sonuç bulunamadı', 'info');
                }

            } catch (error) {
                hideLoading();
                console.error('Search error:', error);
                showToast('Arama sırasında hata oluştu', 'error');
            }
        }

        async function searchInPageOptimized(pageNum, originalQuery, lowerQuery) {
            try {
                // Check if page text is already cached
                const cacheKey = `page_text_${pageNum}`;
                let text, lowerText;

                if (pageCache.has(cacheKey)) {
                    const cachedText = pageCache.get(cacheKey);
                    text = cachedText.original;
                    lowerText = cachedText.lower;
                } else {
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    text = textContent.items.map(item => item.str).join(' ');
                    lowerText = text.toLowerCase();

                    // Cache for future searches
                    pageCache.set(cacheKey, { original: text, lower: lowerText });
                }

                const results = [];
                let index = lowerText.indexOf(lowerQuery);

                while (index !== -1) {
                    const start = Math.max(0, index - 40);
                    const end = Math.min(text.length, index + originalQuery.length + 40);
                    const excerpt = text.substring(start, end);

                    results.push({
                        pageNum: pageNum,
                        text: excerpt,
                        query: originalQuery,
                        index: index
                    });

                    index = lowerText.indexOf(lowerQuery, index + 1);
                }

                return results;

            } catch (error) {
                console.error(`Error searching page ${pageNum}:`, error);
                return [];
            }
        }

        async function performSearchOriginal() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) {
                showToast('Arama terimi girin!', 'warning');
                return;
            }

            showLoading('Aranıyor...', 0);
            searchResults = [];
            currentSearchIndex = -1;

            try {
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    const text = textContent.items.map(item => item.str).join(' ');
                    const lowerText = text.toLowerCase();
                    const lowerQuery = query.toLowerCase();

                    let index = lowerText.indexOf(lowerQuery);
                    while (index !== -1) {
                        const start = Math.max(0, index - 40);
                        const end = Math.min(text.length, index + query.length + 40);
                        const excerpt = text.substring(start, end);

                        searchResults.push({
                            pageNum: pageNum,
                            text: excerpt,
                            query: query,
                            index: index
                        });

                        index = lowerText.indexOf(lowerQuery, index + 1);
                    }

                    updateProgress(Math.round((pageNum / totalPages) * 100));
                }

                hideLoading();

                if (searchResults.length > 0) {
                    currentSearchIndex = 0;
                    displaySearchResults();
                    goToPage(searchResults[0].pageNum);
                    showToast(`${searchResults.length} sonuç bulundu`, 'success');
                } else {
                    showToast('Hiçbir sonuç bulunamadı', 'warning');
                }

            } catch (error) {
                hideLoading();
                showToast('Arama sırasında hata oluştu', 'error');
                console.error('Search error:', error);
            }
        }

        function displaySearchResults() {
            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '';

            if (searchResults.length === 0) {
                resultsContainer.style.display = 'none';
                return;
            }

            resultsContainer.style.display = 'block';

            const resultInfo = document.createElement('div');
            resultInfo.style.marginBottom = '15px';
            resultInfo.style.fontWeight = 'bold';
            resultInfo.style.color = 'white';
            resultInfo.style.textAlign = 'center';
            resultInfo.innerHTML = `
                <i class="fas fa-search" style="margin-right: 8px; color: var(--accent-color);"></i>
                ${searchResults.length} sonuç bulundu
            `;
            resultsContainer.appendChild(resultInfo);

            searchResults.slice(0, 15).forEach((result, index) => {
                const resultItem = document.createElement('div');
                resultItem.style.padding = '12px 15px';
                resultItem.style.marginBottom = '10px';
                resultItem.style.background = 'rgba(255, 255, 255, 0.1)';
                resultItem.style.borderRadius = '8px';
                resultItem.style.cursor = 'pointer';
                resultItem.style.transition = 'all 0.2s ease';
                resultItem.style.borderLeft = '4px solid transparent';

                if (index === currentSearchIndex) {
                    resultItem.style.background = 'rgba(52, 152, 219, 0.3)';
                    resultItem.style.borderLeftColor = 'var(--accent-color)';
                }

                const pageInfo = document.createElement('div');
                pageInfo.style.fontSize = '13px';
                pageInfo.style.color = 'var(--accent-color)';
                pageInfo.style.fontWeight = 'bold';
                pageInfo.style.marginBottom = '6px';
                pageInfo.innerHTML = `<i class="fas fa-file-alt" style="margin-right: 6px;"></i>Sayfa ${result.pageNum}`;

                const textInfo = document.createElement('div');
                textInfo.style.fontSize = '14px';
                textInfo.style.lineHeight = '1.4';
                textInfo.style.color = 'rgba(255, 255, 255, 0.9)';
                textInfo.innerHTML = highlightSearchTerm(result.text, result.query);

                resultItem.appendChild(pageInfo);
                resultItem.appendChild(textInfo);

                resultItem.onclick = () => {
                    currentSearchIndex = index;
                    goToPage(result.pageNum);
                    displaySearchResults();
                };

                resultItem.onmouseenter = () => {
                    if (index !== currentSearchIndex) {
                        resultItem.style.background = 'rgba(255, 255, 255, 0.15)';
                        resultItem.style.borderLeftColor = 'rgba(255, 255, 255, 0.3)';
                    }
                };

                resultItem.onmouseleave = () => {
                    if (index !== currentSearchIndex) {
                        resultItem.style.background = 'rgba(255, 255, 255, 0.1)';
                        resultItem.style.borderLeftColor = 'transparent';
                    }
                };

                resultsContainer.appendChild(resultItem);
            });
        }

        function highlightSearchTerm(text, query) {
            const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi');
            return text.replace(regex, '<span style="background: linear-gradient(45deg, #ffeb3b, #ffc107); color: black; padding: 2px 4px; border-radius: 3px; font-weight: bold;">$1</span>');
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function findNext() {
            if (searchResults.length === 0) {
                showToast('Önce arama yapın!', 'warning');
                return;
            }

            currentSearchIndex = (currentSearchIndex + 1) % searchResults.length;
            goToPage(searchResults[currentSearchIndex].pageNum);
            displaySearchResults();
            showToast(`Sonuç ${currentSearchIndex + 1}/${searchResults.length}`, 'info');
        }

        function findPrevious() {
            if (searchResults.length === 0) {
                showToast('Önce arama yapın!', 'warning');
                return;
            }

            currentSearchIndex = currentSearchIndex <= 0 ? searchResults.length - 1 : currentSearchIndex - 1;
            goToPage(searchResults[currentSearchIndex].pageNum);
            displaySearchResults();
            showToast(`Sonuç ${currentSearchIndex + 1}/${searchResults.length}`, 'info');
        }

        function clearSearch() {
            searchResults = [];
            currentSearchIndex = -1;
            document.getElementById('searchInput').value = '';
            hideSearchResults();
            showToast('Arama temizlendi', 'info');
        }

        function hideSearchResults() {
            document.getElementById('searchResults').style.display = 'none';
        }

        // URL Modal Functions
        function openUrlModal(event) {
            if (event) event.stopPropagation();
            document.getElementById('urlModal').classList.add('show');
            document.getElementById('urlInput').focus();
        }

        function closeUrlModal() {
            document.getElementById('urlModal').classList.remove('show');
            document.getElementById('urlInput').value = '';
        }

        function handleUrlKeyPress(event) {
            if (event.key === 'Enter') {
                loadFromUrl();
            }
        }

        // Recent Files Management
        function loadRecentFiles() {
            try {
                const stored = localStorage.getItem('recentPDFFiles');
                if (stored) {
                    recentFiles = JSON.parse(stored);
                }

                const savedTheme = localStorage.getItem('pdfViewerTheme');
                if (savedTheme) {
                    selectTheme(savedTheme);
                }

                const storedNotes = localStorage.getItem('pdfViewerNotes');
                if (storedNotes) {
                    notes = JSON.parse(storedNotes);
                }
            } catch (error) {
                console.error('Error loading recent files:', error);
            }
        }

        function saveRecentFiles() {
            try {
                localStorage.setItem('recentPDFFiles', JSON.stringify(recentFiles));
            } catch (error) {
                console.error('Error saving recent files:', error);
            }
        }

        function addToRecentFiles(fileName, pages, url = null, lastPage = 1) {
            const newFile = {
                name: fileName,
                pages: pages,
                date: new Date().toLocaleString('tr-TR'),
                timestamp: Date.now(),
                url: url,
                lastPage: lastPage || 1,
                path: url || fileName
            };

            recentFiles = recentFiles.filter(file =>
                file.name !== fileName && file.path !== (url || fileName)
            );

            recentFiles.unshift(newFile);
            recentFiles = recentFiles.slice(0, 10);

            saveRecentFiles();
        }

        function updateRecentFileLastPage() {
            if (currentFileInfo && currentPage) {
                const recentIndex = recentFiles.findIndex(file =>
                    file.name === currentFileInfo.name ||
                    file.path === (currentFileInfo.url || currentFileInfo.name)
                );

                if (recentIndex !== -1) {
                    recentFiles[recentIndex].lastPage = currentPage;
                    saveRecentFiles();
                }
            }
        }

        function showRecentFiles(event) {
            if (event) event.stopPropagation();
            const modal = document.getElementById('recentFilesModal');
            const list = document.getElementById('recentFilesList');

            if (recentFiles.length === 0) {
                list.innerHTML = `
                    <div style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px; font-size: 16px;">
                        <i class="fas fa-history" style="font-size: 64px; margin-bottom: 20px; display: block; opacity: 0.3;"></i>
                        Henüz açılan dosya yok
                        <div style="font-size: 14px; margin-top: 15px; opacity: 0.7; line-height: 1.4;">
                            PDF dosyalarını buradan hızlıca tekrar açabilirsiniz.<br>
                            Son bakılan sayfa bilgisi de kaydedilir.
                        </div>
                    </div>
                `;
            } else {
                list.innerHTML = recentFiles.map(file => `
                    <div class="recent-file-item" onclick="loadRecentFile('${encodeURIComponent(JSON.stringify(file))}')">
                        <div class="recent-file-name">
                            <i class="fas fa-file-pdf" style="margin-right: 10px; color: #e74c3c; font-size: 16px;"></i>
                            ${file.name}
                        </div>
                        <div class="recent-file-details">
                            <span class="recent-file-pages">
                                <i class="fas fa-file-alt" style="margin-right: 6px;"></i>
                                ${file.pages} sayfa
                            </span>
                            <span class="recent-file-date">
                                <i class="fas fa-clock" style="margin-right: 6px;"></i>
                                ${file.date}
                            </span>
                        </div>
                        <div class="recent-file-lastpage">
                            <i class="fas fa-bookmark" style="margin-right: 6px; color: var(--accent-color);"></i>
                            Son bakılan: Sayfa ${file.lastPage || 1}
                        </div>
                    </div>
                `).join('');
            }

            modal.classList.add('show');
        }

        async function loadRecentFile(encodedFileData) {
            try {
                const file = JSON.parse(decodeURIComponent(encodedFileData));
                hideRecentFiles();

                if (file.url) {
                    showToast(`"${file.name}" yükleniyor...`, 'info');
                    await loadFromUrlDirect(file.url);

                    if (file.lastPage && file.lastPage > 1) {
                        setTimeout(() => {
                            goToPage(file.lastPage);
                            showToast(`Son bakılan sayfa: ${file.lastPage}`, 'info');
                        }, 1500);
                    }
                } else {
                    showToast('Bu dosya artık mevcut değil (yerel dosya)', 'warning');
                }
            } catch (error) {
                showToast('Dosya yüklenirken hata oluştu', 'error');
                console.error('Error loading recent file:', error);
            }
        }

        function hideRecentFiles() {
            document.getElementById('recentFilesModal').classList.remove('show');
        }

        function clearRecentFiles() {
            if (confirm('Tüm son açılan dosyaları temizlemek istediğinizden emin misiniz?')) {
                recentFiles = [];
                saveRecentFiles();
                hideRecentFiles();
                showToast('Son açılan dosyalar temizlendi', 'success');
            }
        }

        // Rotation Functions
        async function rotatePDF(angle) {
            if (!pdfDoc) {
                showToast('Önce bir PDF yükleyin!', 'warning');
                return;
            }

            rotation = (rotation + angle) % 360;
            showLoading('PDF döndürülüyor...', 0);

            try {
                await rerenderVisiblePages();
                hideLoading();
                showToast(`PDF ${angle > 0 ? 'sağa' : 'sola'} döndürüldü (${rotation}°)`, 'success');

                updateRecentFileLastPage();
            } catch (error) {
                hideLoading();
                showToast('PDF döndürülürken hata oluştu', 'error');
            }
        }

        // Utility Functions
        function showPDFContainer() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('pdfContainer').classList.add('show');
        }

    let lastPDFVisible = false;

    function goHome(permanent = false) {
        const pdfContainer = document.getElementById('pdfContainer');
        const welcomeScreen = document.getElementById('welcomeScreen');

        // Eğer PDF görünüyorsa → Ana sayfaya geç (geçici veya kalıcı)
        if (pdfContainer.classList.contains('show')) {
            lastPDFVisible = !permanent;

            pdfContainer.classList.remove('show');
            welcomeScreen.style.display = 'flex';

            document.querySelectorAll('.drawing-tool.active').forEach(btn => btn.classList.remove('active'));
            document.getElementById('drawingToolbar')?.classList.remove('show');

            if (permanent) {
                updateRecentFileLastPage();

                if (visiblePageObserver) {
                    visiblePageObserver.disconnect();
                }

                pdfDoc = null;
                currentPage = 1;
                totalPages = 0;
                currentFileInfo = null;
                pageCache.clear();
                searchResults = [];
                bookmarks = [];
                highlights.clear();
                selectedDrawings.clear();
                copiedDrawings = [];
                measurements.clear();
                textEditors.clear();
                numberLines.clear();
                activeSelections.clear();
                persistentDrawings.clear();
                clearAllSelections();
                finishManipulation();
                updatePageInfo();
            }

            hideAllModals();
            showToast('Ana sayfaya dönüldü', 'info');
        }

        // PDF zaten kapalıysa ve önceden açıksa → geri dön
        else if (lastPDFVisible) {
            lastPDFVisible = false;
            pdfContainer.classList.add('show');
            welcomeScreen.style.display = 'none';
            showToast('PDF tekrar yüklendi', 'success');
        }
    }


        function toggleBookmarks(event) {
            if (event) event.stopPropagation();
            const panel = document.getElementById('bookmarksPanel');
            panel.classList.toggle('show');

            if (panel.classList.contains('show') && bookmarks.length === 0) {
                showToast('PDF yüklendiğinde yer imleri burada görünecek', 'info');
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    showToast('Tam ekran modu açık - ESC ile çıkabilirsiniz', 'success');
                }).catch(() => {
                    showToast('Tam ekran moduna geçilemedi', 'error');
                });
            } else {
                document.exitFullscreen().then(() => {
                    showToast('Tam ekran modu kapalı', 'info');
                });
            }
        }

        function toggleInfo() {
            showInfoPopup();
        }

        function hideAllModals() {
            document.querySelectorAll('.theme-popup, .recent-files-modal, .notes-modal, .modal-overlay, .info-popup, .hotkey-popup').forEach(modal => {
                modal.classList.remove('show');
            });
            document.getElementById('bookmarksPanel').classList.remove('show');
            document.getElementById('autoScrollContainer').classList.remove('show');
            document.getElementById('zoomContainer').classList.remove('show');
            document.getElementById('thumbnailPanel').classList.remove('show');
            hideContextMenu();
            clearAllSelections();
            finishManipulation();

            // Cleanup thumbnail observer when closing
            if (thumbnailObserver) {
                thumbnailObserver.disconnect();
                thumbnailObserver = null;
            }
        }

        // Loading and Progress
        function showLoading(text, progress) {
            const overlay = document.getElementById('loadingOverlay');
            const textElement = document.getElementById('loadingText');
            const progressElement = document.getElementById('progressFill');

            textElement.textContent = text;
            progressElement.style.width = Math.min(progress, 100) + '%';
            overlay.classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('show');
        }

        function updateProgress(progress) {
            document.getElementById('progressFill').style.width = Math.min(progress, 100) + '%';
        }

        // Notes Management Functions
        function showNotesModal(event) {
            if (event) event.stopPropagation();
            const modal = document.getElementById('notesModal');
            displayNotes();
            modal.classList.add('show');
        }

        function hideNotesModal() {
            document.getElementById('notesModal').classList.remove('show');
            document.getElementById('noteInput').value = '';
        }

        let isNotePriorityActive = false;

        function toggleNotePriority() {
            isNotePriorityActive = !isNotePriorityActive;
            const btn = document.getElementById('notePriority');
            if (isNotePriorityActive) {
                btn.classList.add('active');
                btn.style.background = 'var(--note-favorite)';
                btn.style.color = 'black';
            } else {
                btn.classList.remove('active');
                btn.style.background = 'rgba(255, 255, 255, 0.1)';
                btn.style.color = 'white';
            }
        }

        function addNote() {
            const noteInput = document.getElementById('noteInput');
            const noteCategory = document.getElementById('noteCategory');
            const noteText = noteInput.value.trim();

            if (!noteText) {
                showToast('Lütfen bir not yazın!', 'warning');
                return;
            }

            const newNote = {
                id: Date.now(),
                content: noteText,
                category: noteCategory.value,
                isFavorite: isNotePriorityActive,
                pdfName: currentFileInfo ? currentFileInfo.name : 'Genel Not',
                pageNumber: currentPage || 1,
                date: new Date().toLocaleString('tr-TR'),
                timestamp: Date.now()
            };

            notes.unshift(newNote);
            saveNotes();
            noteInput.value = '';
            noteCategory.value = 'genel';
            isNotePriorityActive = false;
            toggleNotePriority(); // Reset button
            displayNotes();

            const categoryText = noteCategory.options[noteCategory.selectedIndex].text;
            showToast(`${newNote.isFavorite ? '⭐ ' : ''}Not eklendi: ${categoryText}`, 'success');
        }

        function deleteNote(noteId) {
            if (confirm('Bu notu silmek istediğinizden emin misiniz?')) {
                notes = notes.filter(note => note.id !== noteId);
                saveNotes();
                displayNotes();
                showToast('Not silindi', 'info');
            }
        }

        function displayNotes() {
            const notesList = document.getElementById('notesList');

            if (notes.length === 0) {
                notesList.innerHTML = `
                    <div class="no-notes">
                        <i class="fas fa-sticky-note"></i>
                        Henüz not yok
                        <div style="font-size: 14px; margin-top: 15px; opacity: 0.7; line-height: 1.4;">
                            PDF'leri okurken notlar alabilir,<br>
                            daha sonra buradan görüntüleyebilirsiniz.
                        </div>
                    </div>
                `;
                return;
            }

            notesList.innerHTML = notes.map(note => `
                <div class="note-item">
                    <div class="note-content">${note.content}</div>
                    <div class="note-meta">
                        <div class="note-info">
                            <span class="note-pdf">
                                <i class="fas fa-file-pdf"></i>
                                ${note.pdfName}
                            </span>
                            <span class="note-page">
                                <i class="fas fa-bookmark"></i>
                                Sayfa ${note.pageNumber}
                            </span>
                            <span class="note-date">
                                <i class="fas fa-clock"></i>
                                ${note.date}
                            </span>
                        </div>
                        <button class="note-delete" onclick="deleteNote(${note.id})" title="Notu Sil">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function saveNotes() {
            try {
                localStorage.setItem('pdfViewerNotes', JSON.stringify(notes));
            } catch (error) {
                console.error('Error saving notes:', error);
                showToast('Notlar kaydedilirken hata oluştu', 'error');
            }
        }

        // ENHANCED TOOLBAR DRAGGING FUNCTIONALITY
        function setupToolbarDragging() {
            const toolbar = document.getElementById('drawingToolbar');
            const moveHandle = document.getElementById('toolbarMoveHandle');

            moveHandle.addEventListener('mousedown', startDragging);
            moveHandle.addEventListener('touchstart', startDragging, { passive: false });

            function startDragging(e) {
                e.preventDefault();
                e.stopPropagation();

                isDraggingToolbar = true;
                toolbar.classList.add('dragging');

                const rect = toolbar.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                toolbarDragOffset = {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };

                document.addEventListener('mousemove', handleDragging);
                document.addEventListener('mouseup', stopDragging);
                document.addEventListener('touchmove', handleDragging, { passive: false });
                document.addEventListener('touchend', stopDragging);
            }

            function handleDragging(e) {
                if (!isDraggingToolbar) return;

                e.preventDefault();
                e.stopPropagation();

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                let newX = clientX - toolbarDragOffset.x;
                let newY = clientY - toolbarDragOffset.y;

                const maxX = window.innerWidth - toolbar.offsetWidth;
                const maxY = window.innerHeight - toolbar.offsetHeight;

                newX = Math.max(0, Math.min(newX, maxX));
                newY = Math.max(0, Math.min(newY, maxY));

                toolbar.style.left = newX + 'px';
                toolbar.style.top = newY + 'px';
                toolbar.style.transform = 'none';
            }

            function stopDragging(e) {
                if (!isDraggingToolbar) return;

                e.preventDefault();
                e.stopPropagation();

                isDraggingToolbar = false;
                toolbar.classList.remove('dragging');

                document.removeEventListener('mousemove', handleDragging);
                document.removeEventListener('mouseup', stopDragging);
                document.removeEventListener('touchmove', handleDragging);
                document.removeEventListener('touchend', stopDragging);

                const rect = toolbar.getBoundingClientRect();
                localStorage.setItem('toolbarPosition', JSON.stringify({
                    left: rect.left,
                    top: rect.top
                }));

                showToast('Araç çubuğu konumu kaydedildi', 'success');
            }

            const savedPosition = localStorage.getItem('toolbarPosition');
            if (savedPosition) {
                try {
                    const pos = JSON.parse(savedPosition);
                    if (pos.left >= 0 && pos.top >= 0 &&
                        pos.left < window.innerWidth - 100 &&
                        pos.top < window.innerHeight - 100) {
                        toolbar.style.left = pos.left + 'px';
                        toolbar.style.top = pos.top + 'px';
                        toolbar.style.transform = 'none';
                    }
                } catch (e) {
                    console.log('Could not restore toolbar position');
                }
            }
        }

        // ULTRA ENHANCED BRUSH AND OPACITY CONTROLS
        function setBrushSize(size) {
            brushSize = parseInt(size);
            document.getElementById('brushSizeDisplay').textContent = size + 'px';
            showToast(`Fırça boyutu: ${size}px`, 'info');
        }

        function setOpacity(opacity) {
            currentOpacity = parseInt(opacity);
            document.getElementById('opacityDisplay').textContent = opacity + '%';
            showToast(`Şeffaflık: ${opacity}%`, 'info');
        }

        // GRID AND SNAP FUNCTIONALITY
        function toggleGrid() {
            isGridEnabled = !isGridEnabled;
            const gridTool = document.getElementById('gridTool');

            if (isGridEnabled) {
                gridTool.classList.add('active');
                document.querySelectorAll('.pdf-page').forEach(pageDiv => {
                    let gridOverlay = pageDiv.querySelector('.grid-overlay');
                    if (!gridOverlay) {
                        gridOverlay = document.createElement('div');
                        gridOverlay.className = 'grid-overlay';
                        pageDiv.appendChild(gridOverlay);
                    }
                    gridOverlay.classList.add('show');
                });
                showToast('Izgara açık', 'success');
            } else {
                gridTool.classList.remove('active');
                document.querySelectorAll('.grid-overlay').forEach(grid => {
                    grid.classList.remove('show');
                });
                showToast('Izgara kapalı', 'info');
            }
        }

        function toggleSnap() {
            isSnapEnabled = !isSnapEnabled;
            const snapTool = document.getElementById('snapTool');

            if (isSnapEnabled) {
                snapTool.classList.add('active');
                showToast('Yakalama açık', 'success');
            } else {
                snapTool.classList.remove('active');
                showToast('Yakalama kapalı', 'info');
            }
        }

        function snapToGrid(point) {
            if (!isSnapEnabled) return point;

            const gridSize = 20;
            return {
                x: Math.round(point.x / gridSize) * gridSize,
                y: Math.round(point.y / gridSize) * gridSize
            };
        }

        // THUMBNAIL PANEL FUNCTIONS
        function toggleThumbnailPanel(event) {
            if (event) event.stopPropagation();
            const panel = document.getElementById('thumbnailPanel');
            const isShowing = panel.classList.contains('show');

            if (isShowing) {
                closeThumbnailPanel();
            } else {
                if (!pdfDoc) {
                    showToast('Önce bir PDF dosyası yükleyin', 'warning');
                    return;
                }
                panel.classList.add('show');
                generateThumbnailsLazy();
                showToast('Sayfa önizlemeleri yükleniyor...', 'info');
            }
        }

        function closeThumbnailPanel() {
            const panel = document.getElementById('thumbnailPanel');
            panel.classList.remove('show');
            showToast('Sayfa önizlemeleri kapatıldı', 'info');
        }

        // Enhanced lazy loading thumbnails for ultra-smooth performance
        let thumbnailObserver = null;
        let thumbnailCache = new Map();

        async function generateThumbnailsLazy() {
            if (!pdfDoc) return;

            const thumbnailGrid = document.getElementById('thumbnailGrid');
            thumbnailGrid.innerHTML = '';

            try {
                // Create placeholder items first for instant display
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    const thumbnailItem = document.createElement('div');
                    thumbnailItem.className = 'thumbnail-item loading';
                    thumbnailItem.setAttribute('data-page', pageNum);

                    if (pageNum === currentPage) {
                        thumbnailItem.classList.add('current');
                    }

                    thumbnailItem.innerHTML = `
                        <canvas class="thumbnail-canvas" id="thumbnail-${pageNum}" width="130" height="184"></canvas>
                        <div class="thumbnail-label">Sayfa ${pageNum}</div>
                    `;

                    thumbnailItem.onclick = () => goToThumbnailPage(pageNum);
                    thumbnailGrid.appendChild(thumbnailItem);

                    // Add fade-in animation delay
                    thumbnailItem.style.animationDelay = `${pageNum * 0.03}s`;
                }

                // Set up intersection observer for lazy loading
                setupThumbnailObserver();

            } catch (error) {
                console.error('Error setting up thumbnails:', error);
                showToast('Önizlemeler hazırlanırken hata oluştu', 'error');
            }
        }

        function setupThumbnailObserver() {
            if (thumbnailObserver) {
                thumbnailObserver.disconnect();
            }

            const options = {
                root: document.getElementById('thumbnailGrid'),
                rootMargin: '50px',
                threshold: 0.1
            };

            thumbnailObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const pageNum = parseInt(entry.target.getAttribute('data-page'));
                        loadThumbnailWhenVisible(pageNum);
                        thumbnailObserver.unobserve(entry.target);
                    }
                });
            }, options);

            // Observe all thumbnail items
            document.querySelectorAll('.thumbnail-item').forEach(item => {
                thumbnailObserver.observe(item);
            });
        }

        async function loadThumbnailWhenVisible(pageNum) {
            const thumbnailItem = document.querySelector(`[data-page="${pageNum}"]`);
            if (!thumbnailItem) return;

            try {
                // Check cache first
                if (thumbnailCache.has(pageNum)) {
                    const cachedData = thumbnailCache.get(pageNum);
                    const canvas = document.getElementById(`thumbnail-${pageNum}`);
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        const img = new Image();
                        img.onload = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                            thumbnailItem.classList.remove('loading');
                        };
                        img.src = cachedData;
                    }
                    return;
                }

                await generateSingleThumbnailOptimized(pageNum);

            } catch (error) {
                console.error(`Error loading thumbnail ${pageNum}:`, error);
                thumbnailItem.classList.remove('loading');
            }
        }

        async function generateSingleThumbnailOptimized(pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: 0.25 });

                const canvas = document.getElementById(`thumbnail-${pageNum}`);
                if (!canvas) return;

                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Use lower quality for faster rendering
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport,
                    intent: 'display',
                    enableWebGL: false,
                    renderInteractiveForms: false
                };

                await page.render(renderContext).promise;

                // Cache the thumbnail
                const dataURL = canvas.toDataURL('image/jpeg', 0.7);
                thumbnailCache.set(pageNum, dataURL);

                // Remove loading state
                const thumbnailItem = document.querySelector(`[data-page="${pageNum}"]`);
                if (thumbnailItem) {
                    thumbnailItem.classList.remove('loading');
                }

            } catch (error) {
                console.error(`Error generating optimized thumbnail for page ${pageNum}:`, error);
            }
        }

        // Remove old thumbnail function - replaced with optimized version

        function goToThumbnailPage(pageNum) {
            if (pageNum >= 1 && pageNum <= totalPages) {
                // Update current page highlight
                const oldCurrent = document.querySelector('.thumbnail-item.current');
                if (oldCurrent) {
                    oldCurrent.classList.remove('current');
                }

                const newCurrent = document.querySelector(`.thumbnail-item:nth-child(${pageNum})`);
                if (newCurrent) {
                    newCurrent.classList.add('current');
                }

                // Navigate to page
                goToPage(pageNum);

                // Close thumbnail panel
                document.getElementById('thumbnailPanel').classList.remove('show');
                showToast(`Sayfa ${pageNum}'a gidildi`, 'success');
            }
        }

        // Enhanced note system with improved scrolling and categories
        function displayNotes() {
            const notesList = document.getElementById('notesList');

            if (notes.length === 0) {
                notesList.innerHTML = `
                    <div class="no-notes">
                        <i class="fas fa-sticky-note"></i>
                        Henüz not yok
                        <div style="font-size: 14px; margin-top: 15px; opacity: 0.7; line-height: 1.4;">
                            PDF'leri okurken notlar alabilir,<br>
                            daha sonra buradan görüntüleyebilirsiniz.
                        </div>
                    </div>
                `;
                return;
            }

            // Sort notes: favorites first, then by timestamp (newest first)
            const sortedNotes = [...notes].sort((a, b) => {
                if (a.isFavorite && !b.isFavorite) return -1;
                if (!a.isFavorite && b.isFavorite) return 1;
                return b.timestamp - a.timestamp;
            });

            const getCategoryIcon = (category) => {
                switch(category) {
                    case 'onemli': return '⭐';
                    case 'calisma': return '📚';
                    case 'is': return '💼';
                    default: return '📝';
                }
            };

            const getCategoryColor = (category) => {
                switch(category) {
                    case 'onemli': return 'var(--note-category-work)';
                    case 'calisma': return 'var(--note-category-study)';
                    case 'is': return 'var(--note-category-personal)';
                    default: return 'var(--accent-color)';
                }
            };

            notesList.innerHTML = sortedNotes.map(note => `
                <div class="note-item" style="border-left-color: ${getCategoryColor(note.category || 'genel')}">
                    ${note.isFavorite ? '<div class="note-favorite-badge"><i class="fas fa-star"></i></div>' : ''}
                    <div class="note-header">
                        <span class="note-category" style="color: ${getCategoryColor(note.category || 'genel')}">
                            ${getCategoryIcon(note.category || 'genel')} ${note.category || 'genel'}
                        </span>
                        ${note.isFavorite ? '<span class="note-priority">⭐ Favori</span>' : ''}
                    </div>
                    <div class="note-content">${note.content}</div>
                    <div class="note-meta">
                        <div class="note-info">
                            <span class="note-pdf">
                                <i class="fas fa-file-pdf"></i>
                                ${note.pdfName}
                            </span>
                            <span class="note-page">
                                <i class="fas fa-bookmark"></i>
                                Sayfa ${note.pageNumber}
                            </span>
                            <span class="note-date">
                                <i class="fas fa-clock"></i>
                                ${note.date}
                            </span>
                        </div>
                        <button class="note-delete" onclick="deleteNote(${note.id})" title="Notu Sil">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');

            // Ensure scrolling works properly
            notesList.scrollTop = 0;
        }

        // Page change tracking for recent files
        window.addEventListener('beforeunload', () => {
            updateRecentFileLastPage();
        });

        window.addEventListener('load', () => {
            const savedTheme = localStorage.getItem('pdfViewerTheme');
            if (savedTheme) {
                selectTheme(savedTheme);
            }
        });

        setInterval(() => {
            updateRecentFileLastPage();
        }, 5000);

        // Enhanced error handling
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            showToast('Bir hata oluştu, lütfen sayfayı yenileyin', 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            showToast('Beklenmeyen bir hata oluştu', 'error');
        });
</script>
</body>
</html>